---
{"dg-publish":true,"permalink":"/czc知识库/4-硕士研究生/科研/1-文献阅读笔记/202105.MLDroid：使用机器学习技术进行 Android 恶意软件检测的框架/","dgPassFrontmatter":true,"created":"2024-07-31T12:20:53.808+08:00","updated":"2024-12-08T12:30:21.145+08:00"}
---


MLDroid—framework for Android malware detection using machine learning techniques

pdf链接：[MLDroid—framework for Android malware detection using machine learning_2021_Mahindru_Sangal](MLDroid—framework%20for%20Android%20malware%20detection%20using%20machine%20learning_2021_Mahindru_Sangal.pdf)

[zotero里打开pdf](zotero://open-pdf/library/items/RVXSGAP3)

未翻译完


---
---
# 摘要

本文介绍了 MLDroid——一种基于 Web 的框架——有助于检测来自 Android 设备的恶意软件。由于 Android 设备的日益普及，恶意软件开发人员每天都在开发恶意软件来威胁系统完整性和用户隐私。所提出的框架通过执行动态分析来检测来自 Android 应用程序的恶意软件。为了检测来自现实应用程序的恶意软件，我们通过选择通过实施特征选择方法获得的特征来训练我们提出的框架。此外，这些选定的特征有助于通过考虑不同的机器学习算法来构建模型。实验在 5,00,000 多个 Android 应用程序上进行。实证结果表明，并行考虑所有四种不同的机器学习算法（即深度学习算法、最远优先聚类、Y-MLP 和非线性集成决策树森林方法）和粗糙集分析作为特征子集选择算法开发的模型实现了检测真实应用程序中的恶意软件的检测率最高可达 98.8%。

关键词 ： 权限, API调用, 特征选择方法, Android应用, 机器学习

# 1 简介

随着无线信号、路由算法[1]的改进以及物联网在市场上的引入，智能手机的产量略有增加。智能手机及其应用程序已成为人类生活不可或缺的一部分。如今，人类的生活完全依赖于智能手机中安装的应用程序。智能手机应用程序可用于多种目的，例如查找位置、转账、与朋友互动、观看电影以及更多功能。要利用这些功能，智能手机用户必须向这些应用程序提供与手机硬件、GPS、互联网和相机交互的权限。通过利用应用程序权限 [2]，网络犯罪分子每天都会开发感染恶意软件的应用程序。根据 G data 发布的报告[3]，他们统计到 2019 年第一季度末每天新增恶意软件应用程序超过 10,000 个。这意味着每 8 秒就可以从任何存储库中找到一个受感染的 Android 应用程序。

由于 Android 的开源性质以及其 Play 商店中免费提供的应用程序数量众多，截至 2019 年底，Android 的市场份额为 87% [4]，占据最大的市场份额 [5]。截至 2019 年第一季度末 [6]，已从不同存储库下载了 260 万个应用程序。根据 Haystack 发布的报告 [7]，70% 的智能手机应用程序从用户智能手机获取数据并将其提供给第三方以获取利益。因此，保护​​Android设备免受恶意软件侵害已成为研究人员和院士的首要任务。

为了检测受恶意软件感染的应用程序，在本研究论文中，我们提出了一个名为 MLDroid 的框架，它是一个基于网络的解决方案。 MLDroid 框架基于特征选择方法的原理，并借助不同的机器学习算法进行训练。为了选择最佳特征进行训练，我们考虑两种不同的特征选择方法，即特征排序方法和特征子集选择方法。在本研究论文中，我们考虑了六种不同的特征排序方法来选择最佳特征，即增益比 [8]、卡方检验 [9]、信息增益 [8]、OneR [8]、主成分分析 (PCA) [10]和逻辑回归分析[11]。我们还考虑了四种不同的特征子集选择方法，即基于相关性的特征选择[12]、粗糙集分析[13]、一致性子集评估方法[14]和过滤子集评估[15]来选择恶意软件检测的最佳特征。在选择恶意软件检测的最佳功能后，我们借助不同的机器学习算法对它们进行训练。

在本文中，我们提出了 MLDroid，这是一种有效且高效的基于 Web 的解决方案，能够根据权限和 API 调用检测恶意软件应用程序。 MLDroid 框架遵循机器学习算法的原理，以 Android 应用程序包 (.apk) 文件作为输入并执行动态分析。为了使 MLDroid 准确工作，我们使用不同的机器学习算法对其进行训练，这些算法的工作原理包括监督、半监督、无监督和混合方法。考虑到 Drebin 数据集 [16] 有 5.5 K 个样本，Malgenome 数据集 [17] 有 1 K 个样本以及我们从不同存储库收集的 MLDroid 数据集 [18]，MLDroid 在众多数据集下实现了高精度的恶意软件检测。 MLDroid 在检测已知和未知恶意软件家族中的恶意软件方面的准确率达到 98.8%。图 1 展示了我们开发 MLDroid 时遵循的阶段列表。在第一阶段，从不同的存储库收集 Android 应用程序包 (.apk)。使用防病毒扫描程序 1 识别所收集的 .apk 文件的类别（即属于良性或恶意软件家族）是在第二阶段完成的。在第三阶段，我们提取了本研究中使用的特征（即权限和 API 调用）。此外，在本研究中，为了选择开发恶意软件检测模型的重要特征，我们实施了特征选择方法。在第五阶段，为了开发有效且高效的 Android 恶意软件检测模型，我们实施了不同的监督、无监督、半监督和混合机器学习算法。最后，为了验证开发的模型是否能够检测现实应用程序中的恶意软件，我们比较了其在三个不同参数上的性能。该研究论文的新颖性和独特性贡献如下：

-  MLDroid 是一种独特且高效的基于 Web 的 Android 恶意软件检测框架，使用权限、API 调用、应用程序评级以及下载应用程序的用户数量作为功能。首先，在MLDroid中上传.apk文件，它会自动开始执行并提取应用程序在安装和执行时所需的权限和API调用。接下来，借助使用机器学习技术构建的经过训练的模型，我们的框架可以轻松区分良性或恶意软件感染的应用程序。 
-  MLDroid 对于检测属于未知家族的恶意软件非常有效且高效。我们使用 30 种不同类别的 Android 应用程序来训练和评估 MLDroid。 MLDroid 是在从现实世界的良性和恶意应用程序中提取的权限和 API 调用的帮助下进行训练的。

本文的其余部分总结如下。昆虫。 2、我们讨论迄今为止针对 Android 恶意软件检测所做的研究。昆虫。 3，我们提出数据集的制定。第 4 节介绍了本研究中实施的特征选择方法。昆虫。 5，我们讨论不同的机器学习算法。昆虫。在图 6 中，我们介绍了文献中用于检测现实应用程序中的恶意软件的不同技术。第 7 节代表性能参数，实验设置在第 7 节中介绍。 8. 第 9 节包含实验结果，即哪种模型最适合从现实应用程序中检测恶意软件。终于到了宗门。 10，我们讨论了有效性的威胁，并在第 10 节中提出了本实证研究的结论。 11.

# 2 相关工作

在本文的这一部分中，我们讨论以前为恶意软件检测开发的方法或框架。此外，我们还讨论了现有文献中存在的差距，以及我们如何在开发恶意软件检测模型时克服这些差距。

崔等人。 [19]利用网络数据包提出了一种基于云计算的恶意软件检测模型。他们利用数据挖掘的原理，通过收集数据包的知识来减少数据包的分支，无论它是否对恶意软件检测有用。他们在研究中提出了 SMMDS，该系统基于机器学习算法的原理来检测恶意软件。恩克等人。 [20]提出了 Kirin 框架，它可以帮助我们根据恶意应用程序在安装期间请求的权限来检测它们。 Kirin 基于一组规则，帮助我们减轻 Android 应用程序恶意软件的影响。纳鲁丁等人。 [21]提出了 STREAM，它自动安装和运行 Android 应用程序并从中提取功能。此外，提取的特征用于在机器学习分类器的帮助下进行训练，以检测 Android 应用程序中的恶意软件。 STREAM有一个缺点，需要消耗大量的系统资源和时间来加载数据。魏等人。 [22]构建基于Android应用程序异常行为的恶意软件检测模型。他们利用Naı̈ve Bayes和逻辑机器学习算法将网络信息作为特征开发模型，并取得了更高的准确率。阿里等人。 [23]提出了一种基于高斯混合的恶意软件检测模型。他们根据 CPU、内存、电池等硬件利用率收集特征，并借助高斯混合对其进行训练。但他们提出的模型有一个局限性：它需要一个远程服务器来进行计算。迪克森等人。 [24]利用智能手机被恶意软件感染时的电池寿命行为开发了一个模型。但是，他们提出的模型无法检测一些复杂的恶意软件。苏亚雷斯·坦吉尔等人[25]研究了基于云的检测或设备上的检测方法，哪种方法更省电。他们提出了一个功率模型，在机器学习算法的帮助下比较这两种方法。基于云的检测方法是检测恶意软件更有效、更好的选择。陈等人。 [26]提出了一种解决方案，当智能手机向外部源发送用户私人信息时，监控智能手机的行为。但他们研究中提供的解决方案并不有效，因为它无法支持实时检测。

全等人。 [27]使用三种不同的功能集，即本机代码、系统调用和 API 调用来检测来自 Android 的恶意软件。检测率取决于预定义的阈值。吴等人。 [28]利用树突状细胞算法开发模型，并将系统调用视为特征。他们通过实施统计方法选择最佳特征并实现了更高的检测率。辛等人。 [29]提出了将API调用和权限视为特征的Android恶意软件检测系统。他们通过使用救济算法来选择特征来训练三种不同的分类器：J48、SVM 和 Naı̈ve Bayes。检测率虽好，但也消耗大量资源，计算负担过大。 Tong 和 Yan [30] 提出了混合方法，通过使用与访问文件和网络相关的单独系统调用和顺序系统调用来检测来自 Android 的恶意软件。他们的方法能够检测未知应用程序的行为，检测率达到 91.76%。但是，所提出的方法有一个局限性，它不能支持实时检测。冯等人。 [31]提出了一种决策模型RevMatch，它根据恶意软件检测历史的原理来决策Android应用程序是否感染恶意软件。这种方法不提供实时检测。在论文[32]中，作者还将深度学习机器学习算法应用在 KDD Cup’99 和 NSL-KDD 数据集上，并获得了可喜的结果。文献[33]讨论了公共区域、私有区域和设备区域通信时的安全相关问题。

Abawajy 和 Kelarev [34] 提出了 ICFS，通过结合特征选择方法和机器学习分类器来检测来自 Android 的恶意软件。郭等人。 [35]提出使用 Naı ̈ve Bayes 作为机器学习算法的智能手机网络行为。他们从良性应用程序和恶意应用程序构建了一种模式，以从未标记的应用程序中发现恶意软件。在最近的研究[36]中，作者提出了应用程序如何侵犯用户隐私以获取用户私人数据的机制。他们提出了一种通用且新颖的防御解决方案，以保护基于 Android 的设备中的资源和数据。恩克等人。 [37]提出了TaintDroid，其工作原理是跟踪网络中的信息流。 TaintDroid 通过文件、程序变量和交叉消息跟踪应用程序通信的恶意行为。该过程非常耗时，无法将应用程序标记为良性或恶意软件。阿巴瓦吉等人。 [38]提出了StackDroid一种多级架构，用于最小化错误率。他们检测到两个不同级别的恶意软件；在第一级，他们考虑多层感知器、随机梯度下降、随机森林和极端随机树，在第二级，他们考虑极端梯度提升作为机器学习分类器来检测来自 Android 的恶意软件。巴雷拉等人。 [39]提出了一种基于权限模型原理的方法，通过在收集的 1100 个 Android 应用程序数据集上实现自组织映射（SOM）。他们分析了用于调查 Android 恶意应用程序的 Android 权限模型。他们实现的 SOM 提供了高维数据的二维可视化。

上述研究工作存在以下局限性：数据集有限、检测率较低、计算负担较高、分类算法的实现有限且无法检测复杂的恶意软件。为了克服第一个限制，在本研究中，我们从第 2 节中提到的不同存储库中收集了 5,00,000 个 Android 应用程序，这些应用程序属于 30 个不同的类别。 4. 此外，为了克服其他限制，我们在提取的特征数据集上实现了十种不同的特征选择方法（即权限、API 调用、下载应用程序的用户数量以及被视为特征的应用程序的评级）。接下来，通过使用不同的机器学习算法，将选定的特征视为构建模型的输入，以便构建合适的模型来检测现实应用程序中的恶意软件。

## 2.1 研究问题

为了开发一种恶意软件检测模型，用于从现实应用程序中检测 Android 恶意软件，并具有更高的检测率，并弥补文献中存在的空白，我们在本研究论文中考虑了以下研究问题：

RQ1 所提出的模型中哪种恶意软件检测模型最适合检测现实应用程序中的恶意软件？
这个问题有助于找到最适合 Android 恶意软件检测的模型。在这项工作中，我们通过考虑十种不同的特征选择方法和二十一种不同的机器学习技术构建了 210 个不同的模型。此外，为了确定哪种模型更适合恶意软件检测，我们考虑不同的性能参数（在监督、半监督和混合机器学习算法的情况下，考虑准确性和 F 测量，在无监督的情况下，两个附加性能参数是在我们的研究中考虑了，即簇内和簇间距离）。

RQ2 所提出的恶意软件检测框架对于检测来自 Android 设备的恶意软件是否有效？
该问题的目标是调查我们的恶意软件检测方法的性能。为此，我们将我们开发的模型的性能与文献中可用的一些现有技术进行比较。

RQ3 在检测应用程序是否恶意的任务中，特征子集是否比所有提取的特征表现更好？
此问题的目的是评估这些功能并调查它们在良性应用程序和恶意应用程序之间的关系。正在考虑使用不同类型的特征缩减方法来查找能够检测应用程序是否恶意的特征子集。 

RQ4 在不同实施的特征排名方法中，哪种方法最适合检测 Android 应用程序属于良性类别还是恶意软件类别的任务？
在特征排名方法中，机器学习算法的效率受到恶意软件数据集的特征和性质的影响。正在使用不同的标准来实施不同的方法来对收集的特征集进行排名。本研究考虑了不同的性能标准，以比较本研究中实现的特征排序方法的性能。

RQ5 在应用的特征子集选择方法中，哪种方法最适合检测 Android 应用程序中的恶意软件？
为了确定适合检测 Android 应用程序良性或恶意软件的功能子集，我们考虑功能子集选择方法。在这项工作中，我们通过使用两个性能标准（即监督、半监督和混合机器学习算法的 F 测量和准确性）来比较不同的方法，而在无监督的情况下，考虑两个额外的性能参数，即集群内和簇间距离。 

RQ6 特征子集选择方法与特征排序方法相比如何？
在本文中，成对 t 检验用于确定特征子集选择方法比特征排序方法更合适，或者两者表现同样好。

RQ7 特征选择方法会影响机器学习方法的结果吗？
可以看出，许多特征选择方法在特定的机器学习方法中表现得非常好。因此，在这项研究工作中，使用不同的机器学习方法来评估不同的特征选择方法来衡量其性能。

# 3 MLDroid数据集的制定

## 3.1 .apk文件的收集

表 1 中提到的先前研究仅使用有限的 Android 应用程序数据集来检查其与恶意软件或良性类别的关联。因此，无法得出与所有 Android 应用程序及其系统相关的通用结论。为了克服这一差距，我们收集了属于三十个不同类别的应用程序，用于概括和加强我们的成果。我们收集 Android 应用程序来从 Promise 存储库构建我们的数据集。我们从 Google 的 Play 商店收集了 5,50,000 个 .apk 文件，2 hiapk、3 appchina、4 Android、5 mumayi、6 gfan、7 slipme8 和 pandaapp.9 在这 5,50,000 个良性 .apk 文件中，5,00,000 个是清楚的。此外，Virus Total10 和 Microsoft Windows Defender 报告称，这些特征是在删除受病毒感染的应用程序后提取的。11 Virus Total 通过防病毒引擎识别受恶意软件影响的应用程序，它包含 60 种防病毒软件的定义。从三个不同的数据集 [50、51] 和 [52] 中收集了总共 55,000 个恶意软件样本。卡迪尔等人。 [50]介绍了 1929 个僵尸网络的 Android 样本集，由 14 个不同的僵尸网络家族组成。 Android 恶意软件基因组项目 [51] 包含 1200 个恶意软件样本的数据集，涵盖当前存在的 Android 恶意软件家族。我们从 AndroMalShare [52] 收集了大约 56,871 个样本及其包名称。从收集的数据集中删除重复的软件包后，我们的研究中剩下 50,000 个独特的恶意软件样本。截至 2019 年 3 月底，从上述来源收集了良性和恶意应用程序。表 2 显示了属于 30 个不同类别的 .apk 文件的数量，即商业、漫画、通信、教育等。为了更好地区分良性应用程序和恶意软件应用程序，我们将 .apk 文件视为属于表 2 中提到的正常、特洛伊木马、后门、蠕虫、僵尸网络和间谍软件类别 12。

![](/img/user/czc知识库/9-无奇不有/9-附件/附件/MLDroid：使用机器学习技术进行 Android 恶意软件检测的框架_image.png)

![](/img/user/czc知识库/9-无奇不有/9-附件/附件/MLDroid：使用机器学习技术进行 Android 恶意软件检测的框架_image-1.png)

## 3.2 特征提取

在从上一小节中提到的各个存储库中识别出 .apk 文件的独特样本后，我们从每个 .apk 文件中提取权限和 API 调用。权限的提取和 API 调用是在模拟器的帮助下执行的（在我们的研究中我们使用 Android studio）。模拟器提供与智能手机相同的 API 级别和执行环境。在我们的研究中，为了从 Android 应用程序中提取权限和 API 调用，我们使用 Android 系统版本 6.0 Marshmallow（即 API 级别 23）并形成实验数据集。以前开发的框架或方法使用以前版本的 Android 来从中提取功能。选择此 Android 版本有两个原因：首先，它要求用户撤销或授予使用智能手机资源的权限；其次，它覆盖了 28.1% 的 Android 设备，高于市场上现有的其他版本 [53] 。为了从收集的 .apk 文件中提取功能，我们在模拟器中执行每个文件，并使用自己编写的 java 代码从“AndroidManifest.xml”中提取权限。应用程序在安装和使用过程中需要这些权限和 API 调用。运行。通过一次又一次地使用相同的过程，我们从 5,00,000 个不同的 Android 应用程序中提取权限，并将它们记录在 .csv 文件格式中。列出权限名称的提取数据集可供研究人员公开使用13,14 以前的研究人员使用有限的功能集来开发恶意软件检测模型。为了克服这一差距，在本研究中，我们提取了 1532 个权限、310 个 API 调用、下载应用程序的用户数量以及应用程序的评级，这有助于我们构建恶意软件检测模型。因此，收集到的每个应用程序都可以表示为一个1844维的布尔向量，其中“1”表示该应用程序需要权限或API调用，“0”表示不需要权限或API调用。不同的应用程序可能会请求相似的执行权限集，这是很常见的。 Google15 给出的权限概述用于描述权限的行为，即“危险”或“正常”。

![](/img/user/czc知识库/9-无奇不有/9-附件/附件/MLDroid：使用机器学习技术进行 Android 恶意软件检测的框架_image-2.png)

## 3.3 特征集的制定

已经开发了几种用于 Android 恶意软件检测的方法 [39,54,55]。在本研究中，我们将提取的 API 调用和权限划分为 30 个不同的特征集，这有助于开发恶意软件检测模型。表 3 显示了我们工作中考虑的功能集的基本描述。

# 4 特征选择方法

根据之前的研究，可以看出，在早期的研究中，许多作者应用了不同的特征排序方法来检测Android应用程序中的恶意软件，并取得了良好的检测率。这表明恶意软件检测模型的结果依赖于作为设计模型输入的特征。选择合适的特征集对于机器学习中的数据预处理任务至关重要。在恶意软件检测领域，一些研究人员使用选择方法来选择适当的特征集。在本文中，我们对 1844 个特征的大集合（分为 30 个不同的特征集）实施了 10 种不同类型的特征选择方法，以识别最佳的特征子集，这有助于以更高的检测率检测恶意软件，并最大限度地减少数字错误分类错误。在文献[56]中，作者还实现了桌面恶意软件检测的特征选择方法，并取得了更高的检测率。特征排序方法和特征子集选择方法可以按以下方式定义： 
– 特征排序方法 这些方法使用某些结论性元素对特征进行排序。此外，可以根据它们的等级选择适当的特征来构建模型。 
– 特征子集选择方法 这些方法旨在搜索具有良好检测能力的特征子集。

![400](/img/user/czc知识库/9-无奇不有/9-附件/附件/MLDroid：使用机器学习技术进行 Android 恶意软件检测的框架_image-3.png)

## 4.1 特征排序方法

这些方法单独对特征进行排序，而不应用任何训练算法。功能的排名取决于它们的分数。根据我们对之前研究的调查，大多数方法都能够计算每个特征的评分。在本研究中，我们采用六种不同的排名方法对特征进行排名。下面解释了各种特征排名方法：

### 4.1.1 增益比特征选择

$$
Gain-Ratio =  \frac {Gain(Z)}{SplitInfoz(X)}  ,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ 
(1)
$$

其中 $Gain(Z)=I(X)-E(Z)$ 和 X 描述了包含m 个具有n 个不同类的实例的集合。对给定样本进行分类所需的即将到来的统计数据是通过使用以下方程计算的： 

$$
I(X)=- \sum _ {i=1}^ {m}  P_ {i}  \log _ {2}  (  p_ {i}  ).\ \ \ \ \ \ \ (2)

$$

在此等式中，$P_i$ 是随机样本可以成为 $C_i$i 类成员的机会，并通过 $z_i/z$ 进行测量：

实例的数量由子集 $N_j$ 中类 $C_i$ 的 $z_{ij}$ 给出：预见的知识依赖于 $F$ 对子集的划分，并表​​示为

$$
E(Z)=-  \sum _ {i=1}^ {M}  I(X)  \frac {n_ {1i}+n_ {2i}+\cdots +n_ {mi}}{n}  \ \ \ \ \ \ \ (3)
$$

$SplitInfo_ F(X)$ 使用以下公式进行测量：

$$
SplitInfo_ F(X)=-  \sum _ {i=1}^ {t}  \frac {|x_ {i}|}{X}  \log _ {2}  (  \frac {|x_ {i}|}{X} ) \ \ \ \ \ \ (4)
$$

$SplitInfo_ F(X)$ 的值向我们展示了通过将训练 X 的数据集划分为 t 个部分（相当于属性 Z 测试的 t 个结果）所获得的细节。

### 4.1.2 卡方检验

该测试用于检查两个事件之间的自决性[9]，在我们的工作中，特征的排名是通过其统计量相对于类别的显着性来预测的。计算值越高意味着对异常值的拒绝，因此，这些特征可以被分析为与检测 Android 应用程序中的恶意软件具有更好的相关性。

### 4.1.3 信息增益特征选择

在信息增益中，特征是根据其与类别的关系来选择的[8]。

### 4.1.4 OneR特征选择

OneR 特征选择方法用于对特征进行分级[8]。为了对各个特征进行排名，它利用了分类机制。其中有价值的特征被认为是常数特征，并将一组值划分为通过简单方法制成的几个分离区间。在本研究中，我们考虑具有更好分类率的特征。

### 4.1.5 主成分分析（PCA）

属性的减少是通过在我们收集的数据集上实施 PCA 来完成的。 PCA 有助于将高维数据空间转换为低维数据空间。低维特征对于检测恶意软件极其重要[10]。多个特征之间的相关性较高，因此利用PCA来重新定位这些相关性不是很高的特征。获得的特征被称为主成分域特征。此外，为了识别数据中的重要模式，主成分的小值就足够了。

### 4.1.6 Logistic回归分析

对于特征排序，正在考虑单变量逻辑回归（ULR）分析来验证每个特征集的重要性程度[11]。在当前的工作中，我们考虑了 LR 模型的两个基准，它们考虑发现每个特征的重要性，并用于对每个特征集进行排名。逻辑回归分析的参数如下：

1. 回归系数值 特征的系数度量表示每个特征集与恶意软件的相关程度。 
2. p值 p值，即显着性水平，显示相关显着性。

## 4.2 特征子集选择方法

这些方法用于检测共同具有最佳检测能力的适当特征子集。这些是建立在这样的假设之上的：当与很少的其他特征相关联或当其自身匹配时，所开发的模型具有更好的检测率和更低的误分类错误值。有几种可行的方法可以识别正确的特征子集，帮助我们检测恶意软件。在这项工作中，考虑了四种不同的特征子集选择方法来计算特征得分。实施的方法如下所示：

### 4.2.1 基于相关性的特征选择

该方法基于相关方法，该方法选择与该类别（即良性或恶意软件）特别相关的特征子集。在本研究论文中，皮尔逊相关性（r：相关系数）用于搜索特征之间的依赖性。如果特征集中“r”的值较高，则表明这些特征之间的相关性较强。这意味着存在统计原因来考虑那些具有较低（或最高）特征值的类以及具有较低（或最高）范围的其他高度相关特征的类。

### 4.2.2 粗糙集分析

这种方法是对传统集的估计，根据特征集的连接来提供原始数据集的上限和下限估计[13]。该正式估计描述了原始数据集的上限和下限。这种方法的应用是从不完美的数据中挖掘数据。该方法用于从提取的特征集中选择减少的特征集。 RSA 使用三种不同的符号，例如近似值、简化属性和信息系统。

1. 近似值 $A=(C,Z),X \subseteq Z$ 和 $Y \subseteq C$  。 X- 最上面 $(XY)$ 和 X- 最下面 $(<uline>X</uline>Y$  的近似值用于估计 Y。最高限度包括可能是该集合的一部分的所有对象，最低近似值包括肯定是该集合的一部分的所有对象。 XY 和 $(<uline>X</uline>Y$ 使用后续方程计算：

$$
\bar{X}Y=\{y_{i}\in U\mid[y_{i}]_{\mathrm{Ind}(B)}\cap Y\neq0\}  \ \ \ \ \ \ \ (5)
$$

$$
\underline{X}Y=\{y_{i}\in U\mid[y_{i}]_{\mathrm{Ind}(B)\cap Y}\} \ \ \ \ \ \ \ (6)
$$

其中 $\mid[y_{i}]_{\mathrm{Ind}(C)}$ 属于连接 $Ind(C)$ 的同一类 $y_i$

2. 约简属性 $A \subseteq B$ 中 $Z (Acc(Z))$ 组的正确性评估确定为：

$$
\mu_B(A)=\frac{\operatorname{card}(\underline{B}Z)}{\operatorname{card}(\bar{B}Z)} \ \ \ \ \ \ (7)
$$

集合 Z 的最高或最高近似中包含的特征数量称为该集合的基数。此外，考虑所有可能的特征集，其精度等于提取的特征集的精度。

3. 信息系统确定为 $Z=(C,B)$ ，其中 C 是一个包含非空受限对象集的宇宙，B 是具有有限数量元素的属性集。对于每个 $b \in B$，都存在一个函数 $F_b : C → V_b$，其中$V_b$表示属性b的值。对于每个 $A \subseteq B$；存在称为 $B-$ 不可辨别关系 (Ind(Z)) 的等价关系。 Ind(Z) 可以定义为：

$$
\mathrm{IND}_A(Z)=\{(x,y)\in C^2\mid\forall a\in Z,a(x)=a(y)\}. \ \ \ \ \ \ (8)
$$

### 4.2.3 一致性子集评估方法

当训练实例应用于属性子集时，该技术通过类值中出现的一致性级别来提供属性子集的重要性。一致性率是借助不一致性率来计算的，其中如果两个数据元素属于不同的类标签（即良性或恶意软件）但具有相同的特征值，则可以认为它们是不一致的。对于这项工作，目标变量（即应用程序）具有两个不同的特征（即，0 表示良性应用程序，1 表示恶意应用程序）。一组特征 (GF) 具有 Z 数量的样本，并且存在 z 数量的实例，其方式为 $_Z = X_1 + X_2 + ... + X_z$ 。实例 $X_i$ 似乎完全位于 A 个样本中，其中标记了 $A_0$ 个样本由 0 和 $A_1$ 的样本数量标记为 1，这里 $A = A_0 × A_1$ ：如果 $A_1$ 小于 $A_0$；那么实例 $X_i$ 的差异计数为 $INC = A- A_0$ ： 特征集的不一致率 (INCR) 通过使用以下公式计算：

$$
\mathrm{INCR}=\frac{\sum_{i=1}^z\mathrm{INC}_i}{Z}\ \ \ \ \\ \ \ (9)
$$

### 4.2.4 过滤子集评估

过滤子集评估是基于从应用任意过滤方法获得的数据集中选择随机子集评估器的原理[15]。过滤技术不基于任何归纳算法。过滤子集评估技术可扩展且快速。

# 5 机器学习技术

之前的研究人员应用了不同的机器学习技术，即监督 [16, 57]、半监督 [58]、无监督 [59, 60] 和混合 [61] 算法来检测来自 Android 设备的恶意软件。在这项研究中，为了开发恶意软件检测框架，我们应用了二十一种不同的机器学习算法。在早期研究的基础上，在权衡资源消耗问题后，我们决定检查后续分类器——（即支持向量机（SVM）[16]、Naı ̈ve Bayes（NB）[57, 62]、随机森林（ RF）[63]、多层感知器（MLP）[64]、逻辑回归（LR）[57]、贝叶斯网络（BN）[57]、Adaboost（AB）[65]、决策树（DT）[57] 、k 最近邻 (KNN) [54]、深度神经网络 (DNN) [66]、自组织映射 (SOM) [39]、Kmean [67, 68]、最远优先聚类 (FF) [69] 、过滤聚类（FC）[70]，基于密度的聚类（DB）[71]，J48？YATSI（Y-J48）[72]，SMO？YATSI（Y-SMO）[72]，MLP？ MLP）[72]、最佳训练集成方法（BTE）[73, 74]、多数投票集成方法（MVE）[73, 74]和非线性集成决策树森林方法（NDTF）[73, 74]。

机器学习分类器的评估通常分为两个后续阶段，即测试和训练。在测试阶段，我们使用通过不同特征选择技术获得的选定特征来训练数据集。这些功能是从良性应用程序和恶意应用程序中提取的。在测试时，在监督、半监督和混合机器学习技术的情况下，通过使用选定的两个性能参数 F-measure 和准确性来测量分类器的结果，在无监督机器学习的情况下，考虑两个附加参数，即簇内和簇间距离。

# 6 MLDroid与不同现有技术的比较

为了验证我们提出的框架是否能够实现更高的检测率，我们将我们提出的模型的结果与下面提到的三种不同技术进行比较：

a。与先前开发的框架的结果比较为了验证我们提出的模型是否可以像以前开发的框架一样检测恶意软件，我们计算了新提出的模型和现有模型的两个性能参数，例如准确性和F-measure。 
b。与不同防病毒扫描程序的结果比较为了比较我们的恶意软件检测模型的性能，我们选择了十个可用的不同防病毒扫描程序，并将它们的检测率与建议模型的检测率进行比较。 
c。已知和未知恶意软件家族的检测此外，为了评估我们提出的模型在检测已知和未知恶意软件家族方面的可靠性，我们使用我们提出的模型测试已知和未知恶意软件家族，并计算检测恶意软件的准确性。

# 7 性能参数评价

在本文的这一部分中，我们讨论了在评估我们提出的恶意软件检测模型时所使用的性能参数的基本定义。混淆矩阵用于计算所有这些参数。它由检测模型构建的实际和检测到的分类信息组成。表 4 展示了恶意软件检测模型的混淆矩阵。在目前的工作中，利用不同的性能参数（即 F 测量、准确性、簇内和簇间距离）来测量恶意软件检测方法的性能。

## 7.1 本研究中用于评估使用监督、半监督和混合机器学习技术开发的模型的性能参数

### 7.1.1 本研究论文中使用的基本术语讨论如下

– 真阳性 (TP) 真阳性是模型正确预测阳性类别的结果。 
– 真负例 (TN) 真负例是模型正确预测负类的结果。 
– 假阳性 (FP) 假阳性是模型错误地预测阳性类别的结果。 
– 假阴性 (FN) 假阴性是模型错误地预测负类的结果。 
– 精度：精度量化了实际属于正类的正类预测的数量。

$$
Precision = \frac{N_{Malware→Malware}}{N_{Malware→Malware}+N_{Benign→Malware}}\ \ \ \ \ \ (10)
$$

– 召回率 召回率量化了数据集中所有正例的正类预测数量。

$$
Recall = \frac{N_{Malware→Malware}}{N_{Malware→Malware}+N_{Malware→Benign}}\ \ \ \ \ \ (11)
$$

### 7.1.2 监督、半监督和混合机器学习技术的准确性和 F 测量

准确度 准确度定义为正确检测受恶意软件感染的应用程序以及良性和受恶意软件感染的应用程序总数。对于监督、半监督和混合机器学习技术，它由下式给出

$$
Accuracy = \frac{N_{Benign→Benign}+N_{Malware→Malware}}{N_{classes}}\ \ \ \ \ \ (12)
$$

F-measure 在这篇研究论文中，我们通过实施不同的机器学习算法开发了不同的恶意软件检测模型。因此，很难比较两个具有高召回率和低精度的不同模型，反之亦然。因此，在本研究中我们使用 Fmeasure 来比较两种不同的模型。 F-measure 有助于同时测量精确度和召回率。 F-measure 使用调和平均值代替算术平均值，通过更多地惩罚极值来定义。

$$
F-measure 
= \frac{2*Precision*Recall}{Precision+Recall}
= \frac{2*N_{Malware→Malware}}{2*N_{Malware→Malware}+N_{Benign→Malware}+N_{Malware→Benign}}\ \ \ \ \ \ (13)
$$

## 7.2 本研究中用于评估使用无监督机器学习技术开发的模型的性能参数

在本文的本小节中，我们讨论使用无监督机器学习算法开发恶意软件检测模型时所使用的性能参数的基本定义。在本工作中，使用了四个性能参数，即簇间距离、簇内距离、F-measure 和准确度。下面我们定义这些参数：

对于这些技术中的每一种，我们首先计算质心，然后计算质心欧几里得距离。如果簇中有 N、d​​ 维数据点：$X_i$，其中 $i=1,2,3,..,N$ 质心 $C_0$ 定义为

$$
\mathbf{C_0}=\frac{\sum_{i=1}^N\mathbf{X_i}}N\ \ \ \ \ \ (14)
$$

接下来，我们定义两个簇的质心之间的质心欧几里德距离。给定两个簇 $C_{01}$ 和 $C_{02}$ 的质心；它们之间的质心欧几里德距离或簇间距离定义为

$$
D_0=((C_{01}-C_{02})^2)^{\frac{1}{2}} \ \ \ \ \ \ \ (15)
$$

簇内距离为了计算簇内距离，我们找到总样本均方根标准差 (RMSSTD)。这是由以下定义的

$$\mathrm{RMSSTD}=\sqrt{\frac{\sum_{j=1}^p\bar{s_j}^2}p} \ \ \ \ \ \ (16)$$

其中 $s_j$ 表示属性的标准差，p 是特征的数量。值越小，观测值相对于变量越同质，反之亦然。由于均方根与尺度相关，因此它只能用于比较使用相似尺度测量变量的数据集的同质性。

F-measure F-measure 是信息检索中使用的精度和召回值的调和平均值[75]。精度显示有多少应用程序位于正确的集群中。簇大小。回忆显示有多少应用程序位于正确的集群中。申请总数。令 i 表示类标签，j 表示聚类，则类 i 和聚类 j 的精度和召回率定义为：

$$\begin{aligned}&\mathrm{Recall}(i,j)=\frac{n_{i,j}}{n_j}\ \ \ \ \ \ \ \ \ \ \ (17)\\&\mathrm{Precision}(i,j)=\frac{n_{i,j}}{n_i}\ \ \ \ \ (18)\end{aligned}$$

其中 $n_{i,j}$ 是集群 j 中具有类标签 i 的应用程序数量，$n_i$ 是具有类标签 i 的应用程序数量，$n_j$ 表示集群 j 中的应用程序数量。类 i 和簇 j 的 F 测量如下：

$$F(i,j)=\frac{2*\mathrm{Recall}(i,j)*\mathrm{Precision}(i,j)}{\mathrm{Recall}(i,j)+\mathrm{Precision}(i,j)}\ \ \ \ \ \ (19)$$
聚类过程的总 F 度量(F-measure)由下式给出：

$$F=\sum\frac{n_i}n*\max F(i,j)$$

其中 n 是申请总数。

准确率 令 $n_{i,j}$ 为集群 j 中类标签 i 的应用数量，$n_{j,i}$ 为集群 i 中类标签 j 的应用数量，$n_i$ 为类标签 i 的应用数量，$n_j$ 表示集群 i 中类标签 j 的应用数量。集群 j 中的应用程序。那么准确率就变成：

$$\text{Accuracy}=\frac{n_{ij}+n_{ji}}{n_{ij}+n_{ji}+n_{i}+n_{j}}.$$

# 8 实验设置（Experimental setup）

在本节中，我们将解释为了解我们开发的恶意软件检测模型的性能而进行的实验设置。在表 2 中提到的 30 种不同类别的 Android 应用程序上实施了 21 种不同的机器学习算法。所有这些数据集都有不同数量的良性或恶意软件应用程序，足以执行我们的分析。图 2 演示了 MLDroid 框架。第一步，对提取的特征数据集应用特征排序和特征子集选择方法。接下来，我们使用最小最大归一化方法。该方法基于线性变换的原理，将特征 Q 的每个数据点 $D_{q_i}$ 变为归一化值 $D_{q_i}$ ；位于 0 - 1 之间：考虑以下等式来查找 $D_{q_i}$ 的归一化值 1：

$$\text{Normalized}(D_{q_i})=\frac{D_{q_i}-\min(Q)}{\max(Q)-\min(Q)}$$

其中 min(Q) 和 max(Q) 分别是属性 Q 的最小和最大显着性。第三步，我们通过实施不同的机器学习技术来训练重要的特征（在我们的研究中，我们应用了监督、半监督、无监督和混合机器学习算法）。下一步，我们构建一个混淆矩阵并计算性能参数，即准确性和 F 测量。接下来，我们比较所开发的恶意软件检测模型的性能并选择最佳的恶意软件检测模型。最后，我们将我们提出的恶意软件检测模型的性能与文献中可用的现有技术和不同的防病毒扫描程序进行比较。如果我们提出的恶意软件检测模型的性能优于现有技术，那么它是有用的，反之，如果性能没有比提出的恶意软件模型增强则没有用。

在选择功能子集来构建恶意软件检测模型以检测应用程序是良性还是恶意软件时，将采取后续措施。特征选择方法在 30 个不同的 Android 应用数据集上实现。因此，总共建立了6930个 \[(1 选择所有提取的特征 + 10种特征选择方法) x 30个数据集(进行特征选择后确定的数据集特有的不同特征集的子集) x 21种检测方法\] 不同的检测模型工作。下面我们提供了我们方法的分步细节：

1. 在目前的工作中，在 30 个不同的特征集上实现了四种特征子集选择方法和六种特征排序方法，以选择正确的特征集进行恶意软件检测。 
2. 从上述过程获得的特征子集作为机器学习分类器的输入。为了比较开发的模型，我们使用 20 倍交叉验证方法。交叉验证是一种统计学习方法，用于通过将数据分为两个不同的部分来对模型进行分类和匹配[76]。一部分数据用于训练，其余部分数据用于在训练的基础上验证构建模型[76]。数据最初被分成 K 个相同大小的段。 K-1fold用于训练模型，其余onefold用于测试意图。 K折交叉验证对于利用数据集进行测试和训练具有重要意义。在本研究中，利用 20 倍交叉验证来分析模型，即将数据集分为 20 个部分。所有构建的恶意软件检测模型的结果通过采用两个不同的性能测量参数（F 测量和准确性）来相互匹配。 
3. MLDroid，即利用上述两个步骤构建的模型，使用文献中开发的现有技术进行验证，以审查构建的恶意软件检测模型是否有用。

# 9 实验结果

在本文的当前部分中，提交了不同特征集与类级别恶意软件检测之间的关系。一组特征用作输入，并显示实验中良性应用程序和恶意应用程序的比率。以簇内距离、簇间距离、Fmeasure和准确度作为性能评估参数，以匹配使用21种不同机器学习算法构建的恶意软件检测模型的性能。为了描述实验结果，我们使用表 5 中给出的与其实际名称相对应的缩写。

## 9.1 特征排序方法的结果

在不同的特征集上实现了六种特征排序方法：增益比特征评估、卡方检验、信息增益特征评估、逻辑回归分析、信息增益、oneR特征评估和主成分分析。每种方法都利用不同的性能参数对功能进行排名。此外，正在测量“a”个特征中的顶级 $\lceil\log_2a\rceil$ 特征集，以构建用于检测恶意软件的模型。对于最初的四种特征排序方法（增益比特征评估、卡方检验、OneR 特征评估和信息增益），选择顶部 $\lceil\log_2a\rceil$ 作为特征子集，其中 a 是原始数据集中的特征数量（对于本工作a=20）。然而，在 ULR 的情况下，选择具有正回归系数值的特征，即 p 值测量低于 0.05，而在 PCA 的情况下，仅选择特征值大于 1 的特征。使用特征排序方法如图 3 所示。

![](/img/user/czc知识库/9-无奇不有/9-附件/附件/MLDroid：使用机器学习技术进行 Android 恶意软件检测的框架_image-5.png)

## 9.2 特征子集选择方法的结果

在目前的工作中，四种不同类型的特征子集选择方法在 Android 应用程序的 30 个数据集上相继实现。特征子集选择方法基于假设原理，使模型具有更高的准确性并减少错误分类的错误，同时从可用的特征数量中选择最佳特征。随后，该功能的隔离子集被选为构建模型的输入，以检测应用程序是良性的还是恶意软件。图 4 展示了特征子集选择方法后考虑的特征集。

![](/img/user/czc知识库/9-无奇不有/9-附件/附件/MLDroid：使用机器学习技术进行 Android 恶意软件检测的框架_image-6.png)

![](/img/user/czc知识库/9-无奇不有/9-附件/附件/MLDroid：使用机器学习技术进行 Android 恶意软件检测的框架_image-7.png)

## 9.3 机器学习技术的实现

十一个特征子集（1 考虑所有提取的特征集？ 10 由实施的特征选择方法产生）被用作构建恶意软件检测模型的输入。用于进行本研究的硬件是 Core i7 处理器，具有 1TB 硬盘和 16GB RAM 的存储容量。使用MATLAB环境构建检测模型。每个检测模型的性能是通过使用两个性能参数来衡量的：在监督、半监督和混合机器学习技术的情况下，F-measure 和准确度；在无监督机器学习技术的情况下，我们考虑额外的两个参数，即-簇和簇间距离。表 6、7、8、9、10、11、12、13、14、15、16、17、18、19、20、21、22、23、24、25、26、27、28、29、30和 31 展示了利用不同的机器学习技术针对不同的数据集获得的性能值[^16]。  根据表 6、7、8、9、10、11、12、13、14、15、16、17、18， 19、20、21、22、23、24、25、26、27、28、29、30和31，可以得出结论：

[^16]:在我们的研究中，我们在使用监督机器算法进行训练时无法考虑所有提取的特征，因为它在测试时的准确性较低。

– 通过考虑特征选择方法选择的特征作为输入而开发的模型能够更有效地检测恶意软件，而不是使用所有提取的特征集开发的模型。 
– 通过考虑四种不同的机器学习算法（即 NDTF、Y-MLP、FF 聚类和 DNN）和 FS4[^17] 作为特征子集选择方法开发的 MLDroid 与使用不同特征选择方法开发的其他模型相比，实现了更高的检测率。

[^17]:根据表 6、7、8、9、10、11、12、13、14、15、16、17、18、19、20、21、22、23、24、25、26、27， 28、29、30和31以及箱线图，我们选择最佳的机器学习算法来构建基于网络的恶意软件检测模型。使用 MLDroid 检测恶意软件家族请参见“附录 B”。

在本研究论文中，考虑了不同的机器学习算法和十种不同的特征选择方法来选择有助于我们更有效地检测 Android 恶意软件的特征。为了找出哪个开发的模型更有能力检测恶意软件，我们构建了各个模型的箱线图。箱线图帮助我们根据少量的异常值来确定哪种模型最适合恶意软件检测，并给出更好的中值。图 5、6、7、8 和 9 显示了每个开发模型的 F 测量和精度的箱线图。图表的 x 轴表示特征选择技术。根据箱线图，我们发现以下观察结果：

– 基于箱线图，在所有已实现的特征子集选择方法中，与其他方法相比，使用 FS4 开发的模型给出了最佳结果。 
– 在这项研究中，我们实施了六种不同的特征排名方法来检测 Android 应用程序中的恶意软件。在实施的特征排名方法中，根据箱线图，我们可以得出结论，使用 FR6 开发的模型实现了更高的中值，并且异常值更少。 
– 除了少数异常值之外，通过考虑 FS4 构建的模型还实现了更高的中值。基于图1和2所示的箱线图。如图 5、6、7、8 和 9 所示，与其他开发的方法相比，通过考虑 FS4 作为特征选择方法开发的模型提供了更好的检测率。 
– 从箱线图中，我们观察到考虑 FR6 构建的模型具有很少的异常值和较高的中值。这意味着使用 PCA 开发的用于检测恶意软件和良性应用程序的模型与其他模型相比取得了更好的结果。

![](/img/user/czc知识库/9-无奇不有/9-附件/附件/MLDroid：使用机器学习技术进行 Android 恶意软件检测的框架_image-8.png)
![](/img/user/czc知识库/9-无奇不有/9-附件/附件/MLDroid：使用机器学习技术进行 Android 恶意软件检测的框架_image-9.png)

## 9.4 结果比较

为了确定在已实现的特征选择方法和机器学习算法中哪种技术效果良好或所有技术表现同样好，我们在这项工作中采用了成对 t 检验。

1. 与特征选择方法的结果比较：在这项工作中，对于每个特征选择方法形成两个集合，每个特征选择方法都有630个不同的数据点（21个机器学习技术x 30个数据集）。对不同的特征选择方法进行 t 检验，并比较各自的 p 值来衡量其统计显着性。 t检验研究的结果如图10所示。图中，我们使用两种不同的符号来表示p值，即绿色填充的圆圈具有p值 0:05（没有相关性差异）和圆圈红色填充的 p 值为 0.05（相关性差异）。观察图 10 可以清楚地看到，大多数单元格都充满了绿色圆圈。这意味着所采用的特征选择方法之间不存在相关性差异。此外，通过确定表 32 中给出的平均差的度量，我们观察到，在使用其他实施的特征选择方法进行检查时，通过考虑 FS4 获得的特征集给出了最佳结果。 
2. 与机器学习技术的结果比较：在这项工作中，我们通过检查四个性能参数（即，内部性能参数），在 30 个不同的 Android 应用程序数据集上实现了 11 个不同的特征子集（即，1 个考虑所有特征？ 10 个特征选择方法）。聚类、聚类间、F 测量和准确性，全部包含 330 个数据点（（1 考虑所有特征集？10 个特征选择方法）X 30 个数据集））。图 10 显示了 t 检验分析的结果。根据图 10，可以注意到这些技术之间存在相关性差异，因为 p 值小于 0.05。另一方面，通过确定表 32 中给出的平均值的差异，在已实现的机器学习算法 DNN、FF 聚类、Y-MLP 和 NDTF 中，与其他机器学习技术相比，给出了最佳结果。 
3. 特征子集选择和特征排序方法的比较：在这项工作中，使用成对 t 检验来确定哪种特征选择方法效果更好。对于这两种实现的方法（即特征子集选择和特征排序），研究了性能评估的样本对。表 33 给出了 t 检验分析的平均特征子集选择和特征排序技术结果的性能。在这项工作中，通过选择准确度和 F 度量，将 21 种不同类型的机器学习算法应用于 30 个不同的 Android 类别性能参数；根据每种特征选择方法，总共使用了两个集合，具有 2520 个不同点的特征子集选择（这意味着 4 个特征子集选择方法、21 种机器学习技术、30 个数据集）和具有 3780 个不同数据点（21 个机器学习技术）的特征排名学习技巧 6 个特征排序方法 30 个数据集）。根据表 33，可以看出两种实施的方法之间没有相关变化，因为 p 值大于 0.05。另一方面，与特征排序方法相比，通过计算特征子集选择方法的平均差值可以给出最佳结果。


# 后面一大堆图片-->


