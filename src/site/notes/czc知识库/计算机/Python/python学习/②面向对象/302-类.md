---
{"dg-publish":true,"permalink":"/czc知识库/计算机/Python/python学习/②面向对象/302-类/","dgPassFrontmatter":true,"created":"2024-11-13T18:01:33.508+08:00","updated":"2024-12-08T12:39:45.359+08:00"}
---


# 面向对象基本概念
OOA：面向对象分析analysis
OOD：面向对象设计design
OOP：面向对象编程programing（面向对象开发）

## 对象的概念
对象，object，业务逻辑的动作实体就对应着OOP编程中的一个对象

对象：属性（就是变量）、方法（就是函数（未来完成某个功能））
对象保存数据，方法操作数据

对象怎么来的？由类实例化产生
## 类的概念
python采用类产生对象，用类规定对象的属性和方法


为什么引入类
**类是对现实世界的一种模拟，任何实体都有一个类别，类就是具有相同或相似属性和动作的一组实体的集合**

class 人:
	属性：name、age
	方法：吃饭、跑、扯淡

面向对象：类和对象
- 类是一个抽象概念（具有相同或相似属性和动作的一组实体的集合）
- 对象是类实例化产生的具体事物
- 一个对象的所有应该具有特征特性信息，都是由其所属的类来决定的，但是每个对象又可以具有不同的特征特性信息

比如，
我自己（人类）这个对象，名字叫老王，性别男，会写代码，会教书；
另一个对象（人类）可能叫赵薇，性别女，会演戏，会唱歌！

# 类的定义

经典的类（python2）（很少使用了）：
```python
class 类名:
	属性
	方法
```

新的类（python3）：
```python
class 类名(object):
	属性
	方法
```

object：基类

这就是一个类，只不过里面什么都没有！


## 类的创建（实例的模板）
类是相同或相似属性和方法的一组对象的集合，是一个**抽象概念**。

```python
class Person(object):
	# 属性  # 属性是什么下下面再讲
	# 方法
	def run(self):  # self是啥玩意，后面讲
		print('跑起来了👌')
	def eat(self):
		print('奥里给，干了！💩')
	def speak(self):
		print('随安不是同一时间，但是同一撤硕🚾')
```

- 其中，类名既可以大写也可以小写，遵守一般的标识符的命名规则（以字母数字和下划线构成，并且不能以数字开头），一般为了和方法名相区分，类名的首字母一般大写！(**大驼峰法**:单词首字母大写)
- 类在定义构成中，只是描述了一下未来这个对象所拥有的属性和方法，但是其本身并没有并调用，只有在实例化对象时其才真正执行

## 类的实例化--获取对象
- 类是具有相同或相似属性或方法的一组对象的集合，其是一个抽象概念。要想把其创建为具体的对象，需要经过实例化的过程
- 类是一个抽象概念，可以同时产生多个对象
- 创建的对象都会有类的属性和方法

```python
# 类的实例化
p1 = Person()  # p1就是对象
```

- 对象的方法的调用
	`对象名称.属性`
	`对象名称.方法()`

```python
p1.eat()
p1.speak()
```

> 类是一个抽象概念，在定义时，其并不会真正的占用计算机的内存空间。但是对象是一个具体的事务，所以其要占用计算机的内存空间。


## 对象方法中的self关键字
self的完整版解释在类的属性里讲

self参数和实例化产生的对象内存地址一致，代表两者指向相同的内存空间

self关键字就代表实例化对象本身

```python
class Person(object):
	#属性
	#方法
	def speak(self):
		print(self)
#实例化p1对象
p1 = Person()
print(p1)   # 0x000001CE9D8D2C88
p1.speak()  # 0x000001CE9D8D2C88
p2 = Person()
print(p2)   # 0x00000209498CA448  # 打印的内容是内存地址
p2.speak()  # 0x00000209498CA448  # 内存地址都是一样的
```

self是系统参数，调用方法的时候不需要传参

# 类的属性


我们既可以在类的**内部**也可以在类的**外部**为其对象**添加**属性或**获得**属性

添加和获取属性

## 类的外部动态添加属性

`对象名称.属性 = 属性值`，如果属性值是一个字符串类型，还需要使用引号引起来！

```python
class Person(object):
	# 属性
	# 方法
	def eat(self):
		print('chi')
	def drink(self):
		print('he')
# 实例化产生对象
p1 = Person()
# 在类外添加属性
p1.name = 'a'
p1.age = 1
# 获取属性
print(p1.name)
```

## 类的内部对外部添加的属性进行获取

类的外部**定义**的属性在内部也是可以获取的

```python
# 定义一个类
class Person(object):
	# 定义属性
	# 定义方法
	def print_info(self):
		print(f'name: {self.name}')

# 实例化Person类产生对象
p1 = Person()
# 动态为对象添加属性
p1.name = 'ZhangSan'

p1.print_info()
```

>关于上述代码，`{self.name}`中的`name`会有警告，因为在类中并没有声明这么一个属性，而是需要外部动态添加，如果在外部没有动态添加，那么这个方法将会无法执行。
>内部声明属性相关内容在下一篇文章里写（魔法方法）
### self关键字
self到底代表什么：**代表实例化的对象本身**

在类的内部，我们可以通过对象方法中的seLf关键字来实现对自身属性和方法的调用
①self指向谁？谁实例化这个类，seLf就指向谁（对象）
②self有何作用？可以通过`seLf.属性`或者`self.方法()`形式来实现对自身属性或方法的调用


# 目前的问题

```python
class Person(object):
	# 定义对象方法
	def eat(self):
		print('eat')
	def drink(self):
		print('drink')

p1 = Person()
p1.name = 'a'
p1.age = 50

p2 = Person()
p2.name = 'b'
p2.age = 80
```

对于上述代码，每次实例化一个新的对象，都要一个一个把属性手动添加进对象很麻烦（对象数量大以后，100个对象要添加200个属性，工程量相当大）

所以需要在类的内部直接描述未来对象拥有的公共属性

后来python中引入了**魔术方法**来解决这个臭毛病


# 面试题

请描述什么是对象，什么是类。
 ---
答案：
在面向对象编程中，类和对象是两个重要的概念，它们具有不同的含义和作用。

类是一种抽象的概念，用于定义对象的属性和行为。类是一种自定义的数据类型，可以看作是对象的模板或蓝图。它描述了对象具有的共同特征和行为，定义了对象的属性和方法。

类定义了对象的结构，包括数据成员（属性/实例变量）和函数成员（方法）。通过类，我们可以创建多个相似结构的对象，每个对象都具有相同的属性和方法。

类通常具有以下特征：

- 定义了对象的属性（变量）和方法（函数）。
- 可以被实例化为一个或多个对象。
- 可以通过继承机制派生出子类。
- 提供了封装、继承和多态等面向对象的特性。

对象是类的实例化结果，是类的具体实体。对象是在内存中分配的一块空间，用于存储数据和执行方法。当我们使用类创建对象时，我们可以访问和操作对象的属性和方法。

对象具有以下特征：

- 具有唯一的标识（在内存中的地址）。
- 具有状态（属性值）。
- 可以执行类定义的方法。

简单来说，类是对对象的抽象描述，定义了对象的结构和行为。而对象是类的实例化结果，具体化了类的抽象概念，拥有自己的状态和行为。类是对象的模板，而对象是类的具体实例。

通过创建不同的对象，我们可以利用面向对象编程的特性，实现代码的复用、封装数据和行为，并且更好地组织和管理程序的逻辑结构。


请观阅读如下代码，判断是否能正常运行，如果不能正常运行，错误点在哪？
---

```language
class Person():
    def eat(self):
        print('我喜欢吃零食')

    def drink(this):
        print('我喜欢喝果汁')


p = Person()
p.drink()
Person.eat()
```

答案：
不可以正常运行，eat()方法的调用存在异常，应该用p对象进行调用，注意，drink(this)方法中写this用于替代self是可以的，不存在问题。

