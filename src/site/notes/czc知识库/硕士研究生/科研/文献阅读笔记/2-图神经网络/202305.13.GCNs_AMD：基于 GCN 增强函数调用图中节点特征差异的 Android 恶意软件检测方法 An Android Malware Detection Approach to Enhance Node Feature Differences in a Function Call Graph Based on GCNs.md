---
{"dg-publish":true,"permalink":"/czc知识库/硕士研究生/科研/文献阅读笔记/2-图神经网络/202305.13.GCNs_AMD：基于 GCN 增强函数调用图中节点特征差异的 Android 恶意软件检测方法 An Android Malware Detection Approach to Enhance Node Feature Differences in a Function Call Graph Based on GCNs/","dgPassFrontmatter":true,"created":"2024-06-18T17:45:26.869+08:00","updated":"2024-12-08T12:30:21.229+08:00"}
---


pdf链接：[An Android Malware Detection Approach to Enhance Node Feature Differences in a_2023_Wu et al](An%20Android%20Malware%20Detection%20Approach%20to%20Enhance%20Node%20Feature%20Differences%20in%20a_2023_Wu%20et%20al.pdf)
谷歌翻译pdf链接：[An Android Malware Detection Approach to Enhance Node Feature Differences in a_2023_Wu et al2](../../Zotero/storage/An%20Android%20Malware%20Detection%20Approach%20to%20Enhance%20Node%20Feature%20Differences%20in%20a_2023_Wu%20et%20al2.pdf)
[zotero库位置](zotero://select/library/items/ZQ4HENV5)
[zotero查看原文pdf](zotero://open-pdf/library/items/AGRSCYV4)
***
缩写 本文使用以下缩写： 
GCNs 图卷积网络 
FCG 函数调用图 
FCSG 函数调用子图 
S-FCSG 敏感函数调用子图
AOSP Android 开源项目 
1-D CNN 1-D 卷积神经网络
***
# 论文复现

[GCNs恶意代码检测复现笔记](GCNs恶意代码检测复现笔记.md)
[复现gpt对话记录](复现gpt对话记录.md)

***

**摘要**：智能手机已经成为我们日常生活中不可或缺的工具，而Android操作系统被广泛安装在我们的智能 手机上。这使得Android智能手机成为恶意软件的主要目标。为了应对恶意软件带来的威胁，许多研究人员提出了不同的恶意软件检测方法，包括使用函数调用图（FCG）。虽然FCG可以捕获函数的完整调用者‑被 调用者语义关系，但它将表示为一个巨大的图结构。许多无意义节点的存在影响检测效率。同时，图神经网 络（GNN）的特性使得FCG中的重要节点特征在传播过程中倾向于相似的无意义节点特征。在我们的工作 中，**我们提出了一种Android恶意软件检测方法来增强FCG中的节点特征差异**。**首先，我们提出了一种基于 API 的节点特征，通过该特征我们可以直观地分析应用程序中不同函数的行为属性并确定它们的行为是良性的还是恶意的。然后，我们从反编译的APK文件中提取 FCG 和每个函数的特征。接下来，我们借鉴TF‑IDF 算法的思想计算API系数，并根据API系数排序提取敏感函数子图（S‑FCSG）。最后，在将S‑FCSG和节点特征输入GCN模型之前，我们为S‑FCSG的每个节点添加自循环。一维卷积神经网络和全连接层分别用于 进一步的特征提取和分类**。实验结果表明，我们的方法增强了FCG中节点特征的差异性，检测精度高于使用 其他特征的模型，这表明基于图结构和GNN的恶意软件检测有很大的研究空间。

# 1.  简介

> [!tip]- 恶意代码检测现状介绍
> 随着科技的飞速发展，智能手机已经成为了我们日常生活中不可缺少的工具，目前市面上 智能手机的主流操作系统为Android和iOS，其中Android操作系统占据了主导地位。
> 
> 由于   Android   操作系统很受欢迎，因此它也是恶意软件的首选目标。2021  年，全球  Google   Play  用户下载 了   1113   亿个移动应用，高于2018  年的  760  亿个应用[1]。许多恶意应用隐藏在  Google   Play   Store  中，在 未经用户授权的情况下窃取和修改用户信息。有些甚至会劫持用户的智能手机并强迫他们进行金融交易。
> 
> 许多安全技术公司提供 Android 防病毒产品来帮助人们防御恶意软件。 2019 年 1 月，AV-Comparatives 从 Google Play 商店下载了 250 个由不同开发人员创建的反恶意软件安全应用程序，以测试其反恶意软件程序的有效性 [2]。测试结果显示，80款反恶意软件安全应用程序能够以零误报的方式检测到超过30%的恶意应用程序，其余170款应用程序中的138款检测到低于30%的Android恶意软件样本，32款应用程序被谷歌删除应用商店。现实中，很多Android杀毒产品离线时的检测效率较低，只有连接到在线数据集时才能达到最大的检测效率。
> 
> 为了应对恶意软件带来的威胁，研究人员利用特征工程研究了大量针对Android恶意软件的特征，这些特征大致可分为三大类：静态特征、动态特征和混合特征。静态分析、动态分析和混合分析是获取这三类特征的分析方法[3]。静态分析方法在不执行应用程序的情况下分析应用程序及其关联对象[4]。动态分析方法在应用程序使用时（在真实设备或虚拟环境中）分析特征[4]。混合分析方法是一种将不同形式的静态特征和动态特征相结合的综合方法，包含更全面的特征维度。

近年来，神经网络已经适应利用图的结构和属性[5]，但传统的神经网络模型，如CNN[6]和LSTM[7]，不能直接使用图结构作为输入。图神经网络（GNN）的出现很好地解决了这个问题。作为 GNN 最常用的模型之一，图卷积神经网络（GCN）通过在前向传播过程中聚合相邻节点的特征来更新其下一层节点的特征，这可以看作是低层网络的一种特殊形式。通过过滤[8,9]。基于低通滤波的GCN的特征保留了图中节点特征的共性而不可避免地忽略了差异性，使得学习到的节点特征相似，而重要节点的原始特征丢失了[10]。具有节点特征的函数调用图经过GCN模型前向传播后与邻居节点的特征进行聚合，由于低通滤波特性导致函数调用图中的节点特征相似，导致可能丢失重要的信息节点的原始特征。这不利于模型识别和检测。有没有办法减少该特征的干扰，增强节点特征差异，从而提高模型的检测能力？ 
{ #e04e17}


在本文中，我们从反编译的APK中提取函数调用图（FCG），它可以自动捕获不同函数之间的语义关系，并基于最新的API权限和图结构从每个函数中提取三类特征作为节点特征。然后，我们计算可以代表每个API重要性的API系数，并根据API系数排名提取称为子图（S-FCSG）的敏感函数。 S-FCSG减少了无意义节点的数量，最大限度地保留了节点特征，避免了GCN模型前向传播过程中重要节点特征收敛为无意义节点特征。最后，我们为S-FCSG的每个节点添加自循环，并将其输入到GCN模型中，以便节点特征在节点特征聚合过程中能够再次计算自身，增加不同节点之间特征的差异。三个具有不同卷积核深度的一维卷积神经网络进一步提取节点特征之间的相关性，并使用全连接层进行最终分类。我们的实验结果表明，我们的方法的准确率为 98.28%；因此，我们的方法是有效的。

本文的贡献如下：

- 函数调用图是一种经常使用的静态特征，因为它很好地捕获了函数的意图和行为特征。我们**提出了一种子图提取方法**，可以有效地去除无意义的节点并最大限度地保留节点特征。函数调用子图避免了无意义节点的干扰，降低了函数调用图的邻接矩阵和特征矩阵的维数；
- 我们从Android开源项目[11]中**提取了最新的API保护级别映射关系**，而不是直接使用Pscout[12]中的映射关系。基于API保护级别关系，**我们提出了函数权重特征**，并通过实验证明将该特征嵌入到节点中可以有效帮助神经网络识别和检测Android恶意软件；
- 由于GCN的模型学习是基于低通滤波器的特征，因此图结构中的节点特征在前向传播过程中会收敛到相似性并干扰我们的检测。一方面，我们提取敏感函数调用子图。另一方面，受GCN公式的启发，我们**提出了一种再次聚合其节点特征的方法**，以增强不同节点特征之间的差异；
- 传统的深度学习模型无法直接学习图结构类型的数据。我们**提出了 GCN + 1-D CNN 模型**，利用 GCN 模型来学习函数调用图中不同节点之间的行为特征，并利用不同卷积核深度的 1-D CNN 模型来提取重要节点之间的关联关系。实验结果表明，我们的模型在Android恶意软件检测方法中具有较高的准确率。

本文的其余部分组织如下：第 2 部分描述了 Android 恶意软件检测方面的先前工作。第三节是我们的方法的介绍和实现过程，包括特征提取、图提取和神经网络的建立。第4节描述了实验环境、数据集、实验过程和结果。本文的结论和局限性在第 5 节中介绍。

# 2.相关工作

在本节中，我们将介绍其他研究人员提出的基于静态和动态特征的 Android 恶意软件检测方法。我们描述了方法和模型，并强调了未来工作的主要贡献和方向。我们的研究贡献可以激发进一步的问题和未来的研究方向。

## 2.1.静态特征

通过分析源代码或从有关应用程序的其他信息获得的特征称为静态特征[3]。静态分析可以在安装前检测恶意软件，并且可以在模型环境中检测到，从而降低实验成本。

### 2.1.1.传统静态特征

通过反编译APK文件，创建assets、AndroidManifest.xml、classes.dex等文件目录，研究人员可以从AndroidManifest.xml中获取权限、意图等配置，从classes.dex中获取操作码。他们通常将权限、意图和操作码等数据视为 APK 的特征，并将其输入神经网络进行识别和分类。

吴等人。 [13]提出了一种基于静态特征的机制，称为 DroidMat。他们从AndroidManifest.xml中提取静态特征，包括请求的权限、传递的意图消息、被视为API调用入口点的组件等。接下来，他们使用多种聚类机制来识别恶意软件的不同意图，以增强识别能力。模型的识别能力。最后，他们使用 kNN 算法将应用程序分类为良性或恶意。他们的方法比知名工具Androguard具有更好的准确率（97.87%）和召回率（87.39%），并且分析相同数量的样本所需的时间是Androguard的一半。

李等人。 [14]从应用程序中提取详尽的特征，并将其分为八类：硬件组件、请求的权限、应用程序组件、过滤的意图、受限的API调用、使用的权​​限、可疑的API调用和网络地址，尽管并非所有这些详尽的特征对于 Android 恶意软件检测有意义。然后，他们使用主成分分析（PCA）来选择更重要的特征。与SVM等浅层结构的传统机器学习模型相比，他们选择了三层以上的深度学习模型，即深度神经网络（DNN）作为检测模型。他们以更详细的结果优于其他机器学习方法，达到 97.16% 的精度。未来，他们将考虑结合静态和动态特征来表征Android应用程序。

### 2.1.2.函数调用图 Function Call Graph

函数调用图（FCG）属于一种静态特征。它可以捕获函数的语义信息，而基于权限的静态分析方法则无法做到这一点。

刘等人。 [15]提出了使用 FCG 信息的 G 特征。他们将 G 特征输入机器学习算法来检测恶意软件。他们的方法在最新的恶意软件测试数据集中达到了 86.9% 的准确率，并避免了传统 FCG 的高维向量引起的崩溃问题。范等人。 [16] 提出了一种检测 Android 搭载应用程序的方法，称为 DAPASA。他们使用类似 tf-idf 的算法提取敏感子图 (SSG)，该算法可以分析应用程序最可疑的行为。他们从 SSG 中提取了五个特征来描述调用模式，并将它们输入到机器学习算法中，以检测应用程序是搭载的还是良性的。他们的方法仅用五个数字特征就达到了 94.32% 的准确率。它从调用结构的新角度结合了他们提出的五个功能，对基于权限和基于 API 的方法进行了补充。此外，可以通过构建更详细的行为模型来改进他们的工作。

对于图结构特征，原有的深度学习模型无法直接学习特征。它需要将图结构数据转换为向量，而图神经网络可以直接学习特征。冯等人。 [17]从函数调用关系构建了近似调用图来表示应用程序。他们提取每个函数内属性作为图中的节点特征。然后他们使用图神经网络模型来生成向量表示。他们的方法将传统的静态特征构造成新颖的图结构数据，并且没有基于图结构数据提出新特征。维纳亚卡等人。 [18]捕获了函数之间的调用者-被调用者关系以形成函数调用图。他们考虑了由于APK文件大小的不同而导致函数调用图中节点数量的差异，他们提出了一种平衡技术，使节点数量相似。此外，他们测试了五种不同的 GCN 算法来评估该方法的性能。进行实验来比较不同算法模型的性能。他们测试的最优算法模型达到了 92.29% 的准确率，也在本文中使用。蔡等人。 [19]使用函数调用来学习应用程序的行为特征。他们提出了增强函数调用图（E-FCG）来表征应用程序的运行时行为，并开发了一种基于 GCN 的算法来获取 E-FCG 的向量表示。他们的方法克服了由于缺少功能属性而无法理解应用程序的行为特征以及传统机器学习方法无法直接学习图形表示的问题。

## 2.2.动态特性

> [!NOTE]- 一包动态特征的检测方法论文介绍---**这部分不重要，凑完整性凑字数的部分**
> 当Android应用程序在真实设备或模拟器上运行时，获得的运行时行为特征称为动态特征，用于监视网络流量、电池使用情况、CPU利用率、请求和调用等[3]。
> 
> 加格等人。 [20]提出了基于网络的检测应用程序模型。他们从移动设备上运行的每个应用程序中提取了四种不同流量类别的网络特征，即 DNS、HTTP、TCP 和起点-目的地，并使用机器学习分类器算法来监控和学习不同应用程序的网络行为。他们的方法可以（1）使用网络跟踪检测恶意应用程序，（2）使用不同版本的操作系统，（3）检测未知应用程序，以及（4）使用加密数据检测受感染的应用程序。他们未来的工作将集中于提高未知应用程序的检测率。现有的动态分析方法严重依赖于表征系统调用，并且这些方法容易受到系统调用混淆的影响。
> 
> 蔡等人。 [21]提出了一种称为 DroidCat 的动态应用分类技术来补充现有方法。通过使用基于方法调用和组件间通信 (ICC) 意图的各种动态功能，同时完全处理反射，DroidCat 实现了比静态功能以及依赖系统调用的动态功能更出色的鲁棒性。他们设计了DroidCat在不同条件下的效果效果以及最重要的动态特征。他们发现捕获应用程序执行结构的功能比典型的安全功能（例如敏感流）重要得多。他们的检测技术在对九年来不断发展的应用程序分类方面实现了 97% 的 F1 测量一致准确度。
> 
> 约翰等人。 [22]将系统调用作为代表操作系统交互的特征，并提出了一种使用GCN的检测机制，该机制使用系统调用图的中心性度量作为输入特征。他们是 GCN 在动态 Android 恶意软件检测中的第一个应用，达到了 92.3% 的准确率，并且他们尝试将动态特征与图神经网络模型相结合。塔赫里等人。 [23]提出了一种基于混合特征的检测方法，使用权限和意图作为静态特征，并通过附加提取的 API 调用的 n-gram 顺序关系作为 78 个动态特征来检测和分类 77 个网络流。这种方法是他们贡献的第二部分。在第一部分中，他们介绍了 CICMalDroid 开放可访问数据集并标记了其功能。本文也使用了该数据集。他们计划在未来生成一个 Android 数据集，其中包含更多捕获的特征和大量样本。
> 
> 表1显示了不同研究人员提出的方法及其贡献的比较。与基于权限的静态特征和动态特征相比，具有节点特征的函数调用图可以利用拓扑信息来推断应用程序的行为特征。虽然代码混淆会影响静态特征分析，但函数重命名并不能改变函数调用图的拓扑。可以减少函数重命名带来的影响，同时也避免了动态特性实验成本高、难以触发应用程序全面恶意行为等问题。虽然使用图神经网络模型可以更好、更广泛地利用图结构类型数据，但本文使用静态特征的函数调用图来表示APK文件和GCN来学习图结构数据。我们提出的方法在一定程度上解决了函数调用图和GCN模型带来的缺点，并通过实验证明了我们方法的有效性。
> 
> ![](/img/user/czc知识库/杂七杂八/9-附件/附件/一种基于 GCN 增强函数调用图中节点特征差异的 Android 恶意软件检测方法 An Android Malware Detection Approach to Enhance Node Feature Differences in a Function Call Graph Based on GCNs_image.png)
> 
> ![](/img/user/czc知识库/杂七杂八/9-附件/附件/一种基于 GCN 增强函数调用图中节点特征差异的 Android 恶意软件检测方法 An Android Malware Detection Approach to Enhance Node Feature Differences in a Function Call Graph Based on GCNs_image-1.png)
> 

# 3. Method 

在本节中，我们将重点介绍所提出的**基于API的节点特征函数权重、子图提取方法**以及**添加节点自循环的作用**。如图 1 所示，我们的模型是我们方法的总体框架。首先对已知类别的APK样本进行图结构数据预处理，生成模型所需的函数调用图及其对应的节点特征矩阵。然后，函数调用图和节点特征矩阵被输入到 GCN 和一维 CNN 模型中。随着模型的前向和后向传播，更新模型的参数并对APK样本进行分类。图结构数据预处理和模型检测的过程分为不同的阶段。本节对这些阶段进行了解释，并在图中标记了相应的小节。

![](/img/user/czc知识库/杂七杂八/9-附件/附件/一种基于 GCN 增强函数调用图中节点特征差异的 Android 恶意软件检测方法 An Android Malware Detection Approach to Enhance Node Feature Differences in a Function Call Graph Based on GCNs_image-2.png)

## 3.1.特征提取器

我们的方法从 FCG 和反编译的 APK 文件中提取三种类型的特征。其中两个特征是Dalvik操作码和函数权重，它们是从DEX文件中的每个函数获得的，剩下的一个是基于图结构级别的节点重要性。最后，我们将三类特征连接起来作为FCG的节点特征。

### 3.1.1. Dalvik 操作码

Dalvik是Google专门为Android操作系统设计的虚拟机，操作码存在于DEX文件的代码中。根据 Gabor Paller [24] 提供的操作码列表，我们从**类中的每个方法中**提取 Dalvik 操作码，并**将其多样性分类为我们的第一个特征**。在开始工作之前，我们需要区分内部类和外部类。内部类是从反编译APK的DEX文件中获取的。我们可以获取每个内部类的代码源，但外部类却不能。它们源自第三方库。由于它们的差异，我们使用长度为14的数组来表示每个方法的Dalvik操作码特征。

对于外部类来说，它无法从每个函数中获取详细的代码指令，因此我们将外部类的函数表示为 `dalvik_opcodes[0] = 1`。

对于内部类，我们通过分析内部类的每个函数中的每条指令来获取Dalvik操作码。为了更好地分析每个函数中的这些指令，将它们分为13类，如表2所示。然后根据Dalvik指令操作码获取对应的关键字和i值，并存储为`dalvik_opcodes[i] = 1`。

对于 DEX 文件类中的每个方法，我们将每个方法的 Dalvik 操作码特征表示为
`dalvik_opcodes[i] = 1 (i ∈ [0,13])`。

请注意，如果 `dalvik_opcodes[0] = 1`，则 `dalvik_opcodes[i] (i ∈ [1, 12])` 可能等于 0。反之亦然。
`dalvik_opcodes`是Python中定义的变量数组，总长度为14，用于存储不同索引i处操作码的状态。

![](/img/user/czc知识库/杂七杂八/9-附件/附件/一种基于 GCN 增强函数调用图中节点特征差异的 Android 恶意软件检测方法 An Android Malware Detection Approach to Enhance Node Feature Differences in a Function Call Graph Based on GCNs_image-3.png)


### 3.1.2.节点重要性 Node Importance

FCG 是从反编译的 APK 文件中提取的有向图。在有向图中，每个节点的入度和出度是不同的，而度值可以直接反映该节点的重要性。我们可以根据节点的入度和出度来分析当前节点的行为特征。通常，我们仅对外部类函数节点使用入度，对应用程序初始化函数节点仅使用出度。

在图论和网络分析中，中心性是判断网络中节点影响力的指标。节点的度数越高，该节点的度中心性就越高，意味着该节点在网络中的影响力越大。这就是度中心性[25]。计算公式如下

$$
度中心性=\frac{N_{入度}+N_{出度}}{n-1}
$$

虽然度中心性反映了节点的影响力，包括节点的入度和出度，但我们不能用这个度量来判断该节点是否频繁指向其他节点。我们需要节点的入度和出度值来分析该节点在网络中是否扮演发起者、执行者或中间节点的角色。因此，我们将节点的入度和出度与度中心性结合起来作为**FCG中每个节点的特征**，表示为：节点重要性 = [入度,出度,度中心性]


### 3.1.3.函数权重 Function Weight **API权重**

应用程序编程接口（API）是一些预定义的函数。通过API，可以为应用程序快速扩展功能，而无需了解其如何实现，从而提高开发效率。

程序员经常使用API​​ 来开发Android 应用程序。他们可以通过API从智能手机访问关键信息，但使用API​​需要在AndroidManifest.xml中配置权限，例如android.permission。 READ_SMS 权限 [26] 允许应用程序读取 SMS 消息。虽然每个权限都有其保护级别，但上述权限是危险的，这意味着它具有较高的风险权限，这允许请求授权的应用程序访问用户的私人数据或获得对用户产生不利影响的设备的控制权。我们制作 API 和保护级别之间的映射。然后，我们可以分析DEX文件中的代码，获取应用程序所需的权限保护级别，并计算每个API函数的权重作为FCG的每个节点特征。

计算权重前先*建立两个映射*：**为了创建API和保护级别之间的映射**，需要首先在API和所需权限之间以及权限和保护级别之间进行映射。
- **权限和保护级别之间的映射，从AOSP的AndroidManifest.xml中获取**，
- **API和权限之间的映射**，
	- 有些使用Pscout来构建映射[12]。我们认为 Pscout 是完整的，但已经过时了，因为它的最新地图是基于 2018 年发布的 **Android 5.1**，而这个版本此后已经被几代所取代（最新的 Android 系统是 **Android 13**，于 2022 年 5 月 12 日推出）。
	自Android 6.0（API级别23）以来，Google已通过两种方式正式记录权限规范[27]：
	- **使用Java注解@requiresPermission将API与权限关联起来；**
	- **使用@link android.Manifest.permission#来描述API所需的权限。**
	通过上述两种方式，可以从Android开源项目（AOSP）[11]中提取API对应的权限，形成API权限映射。

我们使用提取的权限保护级别映射和API权限映射来构建**API和保护级别之间的映射**。

如图 2 所示，这是来自 AOSP 的 Java 代码片段。此代码片段可以告诉我们 setActiveAdmin API 需要 MANAGE_DEVICE_ADMINS 和 INTERACT_ACROSS_USERS_FULL 权限。
同样，图 3 告诉我们 getFactoryResetProtectionPolicy API 需要 MASTER_CLEAR 权限。如表3所示，这是我们从图2和图3中提取的字段的解释。从AOSP中总共提取了1640个API。

![](/img/user/czc知识库/杂七杂八/9-附件/附件/一种基于 GCN 增强函数调用图中节点特征差异的 Android 恶意软件检测方法 An Android Malware Detection Approach to Enhance Node Feature Differences in a Function Call Graph Based on GCNs_image-4.png)

![](/img/user/czc知识库/杂七杂八/9-附件/附件/一种基于 GCN 增强函数调用图中节点特征差异的 Android 恶意软件检测方法 An Android Malware Detection Approach to Enhance Node Feature Differences in a Function Call Graph Based on GCNs_image-5.png)

![](/img/user/czc知识库/杂七杂八/9-附件/附件/一种基于 GCN 增强函数调用图中节点特征差异的 Android 恶意软件检测方法 An Android Malware Detection Approach to Enhance Node Feature Differences in a Function Call Graph Based on GCNs_image-6.png)

**根据调用不同API的次数，计算出每个函数的API调用权重**。如果API权限有多个保护级别，则仅取保护级别的最大权重值进行计算。
- 对于**内部类**中的每个函数，将每个函数的 API 调用权重表示为等式（2）。
- 对于**外部类**中的函数，将每个方法的API调用权重表示为自身保护级别的权重值，如等式​​（3）所定义。

**Normal, signature, privileged, and dangerous（普通、签名、特权和危险）是 API 的四种常见保护级别**。由于API权限默认为普通权限，风险较低。系统会自动将此类权限授予应用程序，无需用户明确许可。除正常防护级别外，所有防护级别都存在一定的风险，我们需要充分捕捉已识别的风险和潜在的风险。因此，我们将普通权限的API权重定义为0，其他权限为1。我们使用这种方法计算了数据集中12,898个APK文件（6530个良性APK文件和6368个恶意文件）的函数权重，这些文件是从open获得的可访问的数据集。有关我们工作中使用的数据集的详细信息可以在第 4.2 节中找到。

$$
API\_Call\_Weight_{internal\_method}=\sum\limits^n weight_{protection\ level} \ \ \ \ \ \ \ \ (2)
$$

$$
API\_Call\_Weight_{external\_method}= \max(weight_{API})\ \ \ \ \ \ \ \ \ \ (3)
$$

如果某个函数的API调用权重值较高，则意味着该函数中的API调用次数较多。然而，其他保护级别的 API 调用比危险保护级别的 API 调用要多，这只能意味着该函数中存在更多行为。因此，我们提出了危险防护级别的API调用次数与式（4）定义的API调用总数之间的比率。该比率表示对被识别为危险的 API 的调用的百分比。

$$
ratio_{each\_method}=\frac{dangerous\_api\_call\_counts}{api\_call\_counts} \ \ \ \ \ \ \ \ \ \ \ (4)
$$

我们**选择API调用权重、比率及其乘积作为FCG中每个节点的函数权重特征**，表示为

$$
method\ weight_{each\_method}=[api\_call\_weight, ratio, api\_call\_weight ∗ ratio]
$$

此外，我们对这些功能进行了以下评估：
**评估 1**：从我们的数据集中随机选择 2000 个 APK 文件。
在评估1中，我们计算API调用权重之和与2000个APK文件（1000个恶意软件和1000个良性）的比例，如图4所示。一般来说，API调用权重值越大，APK文件越大。虽然随机选取的2000个APK文件的大小相差很大，但我们可以看到，在相同的权重值下，恶意软件的比例值大于良性的，这意味着该APK文件中具有危险保护权限的API被调用的次数更频繁。在接下来的评估中，我们将从这些样本中选择大小相似的样本来证明这一发现。

![](/img/user/czc知识库/杂七杂八/9-附件/附件/一种基于 GCN 增强函数调用图中节点特征差异的 Android 恶意软件检测方法 An Android Malware Detection Approach to Enhance Node Feature Differences in a Function Call Graph Based on GCNs_image-7.png)

**评估 2**：在评估 1 中选择 300 个大小相似的 APK 文件。
在评估2中，我们从2000个样本中找到300个大小相似的样本（150个恶意软件和150个良性样本），并计算API调用权重的总和以及这些样本的比例，如图5所示。通常，在相同权重值的情况下，恶意软件的比例值大于良性的，而在相同理性值的情况下，恶意软件的权重值大于良性的。因此，恶意软件的权重值和比率值一般都大于良性的。

![](/img/user/czc知识库/杂七杂八/9-附件/附件/一种基于 GCN 增强函数调用图中节点特征差异的 Android 恶意软件检测方法 An Android Malware Detection Approach to Enhance Node Feature Differences in a Function Call Graph Based on GCNs_image-8.png)

正如我们在图 4 和图 5 中看到的，恶意软件更多地分布在散点图的右上侧，而不是良性恶意软件。根据评估 1 和 2 的结果，我们推测恶意软件的权重与比率之间的乘积值通常应大于良性。因此，我们进行评估 3 和 4。
**评估3**：根据评估2计算权重\*比值(weight \∗ ratio)。
如图6所示，基本可以证明我们上面的猜测。

![](/img/user/czc知识库/杂七杂八/9-附件/附件/一种基于 GCN 增强函数调用图中节点特征差异的 Android 恶意软件检测方法 An Android Malware Detection Approach to Enhance Node Feature Differences in a Function Call Graph Based on GCNs_image-9.png)

**评估4**：在评估3中选择100个大小相似的APK文件，计算权重\*比率的值。
为了从图中更清楚地得到我们的推论，我们在减少APK样本数量后再次计算了weight \*ratio的值。如图7所示，我们完全可以证明我们的猜测：恶意软件的权重\*比值通常应该大于良性。

![](/img/user/czc知识库/杂七杂八/9-附件/附件/一种基于 GCN 增强函数调用图中节点特征差异的 Android 恶意软件检测方法 An Android Malware Detection Approach to Enhance Node Feature Differences in a Function Call Graph Based on GCNs_image-10.png)

通过以上四项评估，函数权重中的API调用权重可以在一定程度上反映APK文件的大小。我们可以清楚地发现，对于类似的API调用权重，恶意软件的比率，权重\*比率值通常大于良性的比率。因此，即使没有神经网络的精确计算，我们也可以利用这个特征来粗略地区分APK类别。后面的实验部分表明，使用此节点功能使我们的模型非常有效。

## 3.2.图提取器

在本节中，我们的方法首先**提取函数调用图**（FCG），然后在 FCG 之上提取敏感函数调用子图（S-FCSG）。 S-FCSG的提取包括三个步骤：**计算API系数**、**提取FCSG（函数调用子图）**、**提取S-FCSG（敏感函数调用子图）。

### 3.2.1.生成整个函数调用图 (FCG)

Androguard [28]是一个完整的Python工具，用于处理Android文件，并在我们的工作中用于提取FCG。它可以反编译APK文件并获取类中的函数。通过分析每个函数中的调用指令，以调用函数和被调用函数为节点，根据调用关系添加有向边，构建有向函数调用图。函数调用图可以通过不同函数之间的这种调用-被调用者关系自动捕捉它们的行为特征。如图8所示，从这个有向图中，我们可以发现不同节点之间的调用-被调用关系。

>使用AndroGuard**反编译**APK文件获取**类中的函数**，通过分析每个函数中的调用指令，以**调用**函数和**被调用**函数为节点，根据调用关系添加有向边，**构建有向函数调用图**（FCG）

![](/img/user/czc知识库/杂七杂八/9-附件/附件/一种基于 GCN 增强函数调用图中节点特征差异的 Android 恶意软件检测方法 An Android Malware Detection Approach to Enhance Node Feature Differences in a Function Call Graph Based on GCNs_image-11.png)

### 3.2.2.计算 API 系数

API系数的计算表明API在Android应用程序中的重要性。如果只计算数据集中API出现的频率作为API系数，那么测量就会**有偏差**，例如MIGDroid[29]。

受到 **TF-IDF** [30] **算法思想的启发** ，我们应用适合我们工作的TF-IDF算法来计算API系数，并用API系数来表达这个API的重要性。从上面**从AOSP中提取的**1640个API中，我们选择了978个防护级别较高且调用频率特殊的API，并利用这978个API**构建敏感API集**。
{ #f2fe9b}


定义四个术语来帮助我们计算 API 系数。
- $count(api_i, apk)$：APK中调用$api_i$的次数；
- $count(apk,*)$：APK中调用的API总数；
- $number(c)$：数据集中类型 $c$ 的 APK 数量。 $c$ 表示APK的类别是恶意还是良性；
- $number(api_i)$：调用 $api_i$ 的 APK 数量。

根据**TF-IDF算法**中的公式，我们提出适用于我们工作的公式，如下：

$$
\begin{array}{l}
T F\left(a p i_{i}, a p k\right)=\frac{\operatorname{count}\left(a p i_{i}, a p k\right)}{\operatorname{count}(a p k, *)} \\
\operatorname{IDF}\left(\operatorname{api}_{i}, c\right)=\log \frac{\text { number }(c)}{\text { number }\left(\operatorname{api}_{i}\right)+1} \\
T F-\operatorname{IDF}(c)=T F\left(a p i_{i}, a p k\right) * \operatorname{IDF}\left(a p i_{i}, c\right) \\
\end{array}
$$

TF − IDF(malware) 表示恶意软件的 TF–IDF 值。
TF − IDF(benign) 表示良性的 TF–IDF 值。

为了避免由于未使用的API导致分母为0的程序异常，我们在IDF公式中的log函数的分母上加了1。 

API 系数值应与 TF − IDF（恶意软件）和 TF − IDF（良性）的值成比例。计算公式如下：

$$
\text { API coefficient }\left(\text { api } i_{i}\right)=T F-I D F(\text { malware }) * T F-I D F(\text { benign }) 
$$

通过计算可以得知，在我们的敏感API集合中，getInstance(context)的API系数值排名第一，其在恶意软件和良性软件中的TF和TF-IDF值也排名第一，表明该API被调用的次数最多并且是最重要的。几个具有危险防护级别的 API 排名也很高，例如 `connect(WifiP2pManager$Channel,WifiP2pConfig,WifiP2pManager$ActionListener)、getExternalStorageDirectory() `等。

### 3.2.3.提取函数调用子图 (FCSG)

我们根据**敏感API集合**提取**包含所有敏感API节点**的函数调用子图（FCSG）。如算法1所示，这就是我们的提取过程。

![](/img/user/czc知识库/杂七杂八/9-附件/附件/一种基于 GCN 增强函数调用图中节点特征差异的 Android 恶意软件检测方法 An Android Malware Detection Approach to Enhance Node Feature Differences in a Function Call Graph Based on GCNs_image-12.png)

算法1显示了使用每个应用程序的FCG和敏感API集的输入来提取FCSG的步骤，该FCSG是从我们前面提到的AOSP中提取的。我们定义SBUGRAPH_NODE_LIST变量来保存API节点及其邻居节点。请注意，在提取 FCSG 期间，FCG 被视为无向图。

在算法1中， $shortest\_path(V_i, V_{api})$ 函数用于计算 $V_i$ 和 $V_{api}$ ​​顶点之间的最短距离， $set(SBUGRAPH\_NODE\_LIST)$ 函数用于删除列表中的重复顶点。 $subgraph(FCG, SBUGRAPH\_NODE\_LIST)$ 函数根据 $SBUGRAPH\_NODE\_LIST$ 中的节点提取FCG的子图FCSG。

在 $shortest\_path(V_i, V_{api})$ 函数中，提取最短路径长度小于或等于2的邻居节点。由于我们从数据集中随机选择了2001个APK文件，结果发现平均最短路径长度为API 节点到其邻居节点的路径长度范围为 (2, 4) 处的 APK 数量最多 (94.8%)，只有少数 APK 大于 4，如图 9 所示。为了提取子图，我们设置邻居最短路径长度小于或等于2的节点。

![](/img/user/czc知识库/杂七杂八/9-附件/附件/一种基于 GCN 增强函数调用图中节点特征差异的 Android 恶意软件检测方法 An Android Malware Detection Approach to Enhance Node Feature Differences in a Function Call Graph Based on GCNs_image-13.png)

### 3.2.4.生成敏感函数调用子图 (S-FCSG)

进一步从 FCSG 中提取敏感函数调用子图（S-FCSG）。
如图10所示，这是一个S-FCSG，算法2是提取过程。

![](/img/user/czc知识库/杂七杂八/9-附件/附件/一种基于 GCN 增强函数调用图中节点特征差异的 Android 恶意软件检测方法 An Android Malware Detection Approach to Enhance Node Feature Differences in a Function Call Graph Based on GCNs_image-14.png)

![](/img/user/czc知识库/杂七杂八/9-附件/附件/一种基于 GCN 增强函数调用图中节点特征差异的 Android 恶意软件检测方法 An Android Malware Detection Approach to Enhance Node Feature Differences in a Function Call Graph Based on GCNs_image-15.png)

算法2是使用**FCSG**、**敏感API集**和**API系数列表**作为输入的**S-FCSG提取**过程。该算法的本质是从FCSG中提取API系数高节点的敏感子图。
FCSG在提取过程中也被认为是无向图。

变量SBUGRAPH_NODE_LIST的功能与算法1中变量SBUGRAPH_NODE_LIST的功能相同。

$coefficient\_rank(V_i, API\_COEFFICIENT\_LIST)$ 函数用于计算 API 节点 $V_i$ 的 API 系数的排名，$bfs\_tree(FCSG, V_i)$ 函数利用广度优先搜索来查找 FCSG 中 $V_i$ 所有连通的邻居节点。

在子图提取过程中，我们使用全保留方法将有向图视为无向图。我们随机测试数据集中的3000个样本APK，从按API系数排序的前1、3、5、7、10、20、30个敏感API节点开始提取子图，观察节点数量和节点特征的变化图中分别如表4所示。使用这种方法提取的子图可能包含API系数排名不高的API节点，这些节点是距离API系数排名最高的节点两跳以内的API节点。

通过表4，S-FCSG有效减少了函数调用图中的节点数量，直接降低了图结构的复杂度，同时保留了最大的节点特征和结构。基于图神经网络的特点，S-FCSG避免了图卷积神经网络传播过程中高特征权重节点与无意义节点或不太重要节点相似的倾向，从而减少了冗余节点对网络传播过程的干扰。我们的模型学习。 S-FCSG的邻接矩阵和特征矩阵的维数比FCG小，这加快了下面模型的训练速度并消耗资源。经过比较，我们选择了前 10 个参数的 S-FCSG 进行接下来的实验。

![](/img/user/czc知识库/杂七杂八/9-附件/附件/一种基于 GCN 增强函数调用图中节点特征差异的 Android 恶意软件检测方法 An Android Malware Detection Approach to Enhance Node Feature Differences in a Function Call Graph Based on GCNs_image-16.png)

## 3.3.神经网络模型

在本节中，我们希望使用神经网络模型来自动捕获图结构中不同节点之间的语义关系。

**一种组合的 GCN + 1-D CNN模型**，如图11所示。GCN模型用于直接嵌入**图结构数据**和**节点特征**。在GCN模型的**传播**过程中，可以聚合**当前**节点及其**邻居**的特征，从而允许不同节点之间的特征学习。使用**一维CNN模型**进一步捕获节点特征之间的相关性，经过GCN模型学习后，将捕获的相关特征反馈给全连接网络进行分类。

![](/img/user/czc知识库/杂七杂八/9-附件/附件/一种基于 GCN 增强函数调用图中节点特征差异的 Android 恶意软件检测方法 An Android Malware Detection Approach to Enhance Node Feature Differences in a Function Call Graph Based on GCNs_image-17.png)

### 3.3.1.图卷积网络

对于GCN模型，我们比较两种算法模型：

#### (1)GraphConv[31]：

基普夫等人。考虑多层图卷积网络（GCN）的逐层传播规则，如等式（9）所示：

$$
\begin{array}{c}
H^{(l+1)}=\sigma\left(\tilde{D}^{-\frac{1}{2}} \tilde{A} \tilde{D}^{-\frac{1}{2}} H^{(l)} W^{(l)}\right) 
\end{array} \ \ \ \ \ \ \ \ \ \ \ (9)
$$

$\tilde A$ 是一个邻接矩阵，添加了单位矩阵，该矩阵汇集了每个节点及其邻居的信息。 $W^{(l)}$ 是可学习的权重矩阵，$σ$ 是激活函数。

方程（10）是前向传播模型的简单形式，图12是用于半监督学习的多层图卷积网络（GCN）的示意图。

$$

Z=f(X, A)=\operatorname{softmax}\left(\hat{A} \operatorname{ReLu}\left(\hat{A} X W^{(0)}\right) W^{(1)}\right), \hat{A}=\tilde{D}^{-\frac{1}{2}} \tilde{A} \tilde{D}^{-\frac{1}{2}}\ \ \ \ \ \ \ \ \ \ (10)
$$

![](/img/user/czc知识库/杂七杂八/9-附件/附件/一种基于 GCN 增强函数调用图中节点特征差异的 Android 恶意软件检测方法 An Android Malware Detection Approach to Enhance Node Feature Differences in a Function Call Graph Based on GCNs_image-18.png)

#### (2)GraphSAGE[32]：

GraphSAGE方法与GraphConv密切相关。随着 GraphSAGE 层数的增加，节点聚合来自邻居的特征，并从图的更远的邻居节点获得越来越多的特征。式(11)和(12)是聚合特征的过程。方程(13)是L2归一化。图 13 直观地说明了 GraphSAGE 示例和聚合方法。

$$
\begin{array}{c}
h_{N(i)}^{(l+1)}=\text { AGGREGATE }\left(h_{j}^{l}, \forall j \in N(i)\right) \ \ \ \ \ \ \ \ \ \ (11)
\\
h_{i}^{(l+1)}=\sigma\left(W * \operatorname{concat}\left(h_{i}^{(l)}, h_{N(i)}^{(l+1)}\right)\right) \ \ \ \ \ \ \ \ \ \ (12)
\\

h_{i}^{(l+1)}=\frac{h_{i}^{(l+1)}}{\left\|h_{i}^{(l+1)}\right\|_{2}}
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \  \ \ \ \ \ \ \ \ (13)
\end{array}
$$

![](/img/user/czc知识库/杂七杂八/9-附件/附件/一种基于 GCN 增强函数调用图中节点特征差异的 Android 恶意软件检测方法 An Android Malware Detection Approach to Enhance Node Feature Differences in a Function Call Graph Based on GCNs_image-19.png)

一般来说，GNN中的低通滤波器主要保留了节点特征的共性。它不可避免地忽略差异，因此连接节点的学习特征表示是相似的[10]。同样，论文中提到的GraphConv和GraphSAGE模型使得互连节点的特征表示在模型的前向传播中收敛到相似。在3.2节中，我们提取敏感函数调用子图，并从图中去除无意义节点和不太重要的节点，这样可以有效避免GCN模型前向传播过程中重要节点的特征表示与无意义节点相似。

与GrapConv的算法相比，**GraphSAGE是一种归纳图嵌入，可以嵌入从未出现过的节点，但GraphConv不能。因此，本文采用 GrapSAGE 作为 GCN 模型**
，并将参数 AGGREGATE 设置为 Mean，将 σ 设置为 ReLu。受GraphConv中方程（9）的影响，我们在将S-FCSG输入到GCN模型之前将自循环添加到S-FCSG中，以便让GraphSAGE模型在向前传播聚合的节点特征时再次聚合自己的特征，在防止重要节点与无意义节点特征相似的基础上，进一步增强重要节点的特征。如图 14 所示，这分别显示了 GraphSAGE 模型嵌入之后和具有自循环 S-FCSG 模型嵌入的 GraphSAGE 之后的初始特征权重。在此过程中，我们将模型中的权重和偏差设置为“无”。

![](/img/user/czc知识库/杂七杂八/9-附件/附件/一种基于 GCN 增强函数调用图中节点特征差异的 Android 恶意软件检测方法 An Android Malware Detection Approach to Enhance Node Feature Differences in a Function Call Graph Based on GCNs_image-20.png)

### 3.3.2.全局池化层

S-FCSG具有高维邻接矩阵和节点特征矩阵。我们使用全局池化层来提取关键特征并降低节点特征矩阵的维数。排序池模型[33]用作我们的全局池化层。它首先沿着GCN模型输出的特征维度对节点特征进行升序排序，并选择排序后的前K个节点的特征权重。经过全局池化层之后，不同维度的节点特征矩阵都可以归一化为同一维度，这有利于我们下一个模型的定义和计算。我们将提取的K个节点特征向量组合成K维节点特征矩阵。

K 的大小代表为我们的实验选择的重要节点的数量，我们在下一节中通过实验证明，在全局池化层中使用不同的 K 值会给出不同的实验结果。

### 3.3.3.一维卷积神经网络和全连接层

我们的一维卷积神经网络和全连接层由三个一维卷积层、一个合并层、一个最大池层和一个全连接层组成。每个卷积层都有不同的卷积核深度，用于提取不同粒度的节点之间的行为特征。合并层连接来自一维 CNN 输出的三个节点特征向量，我们将采样内核设置为 3，在下一个最大池化层中将步长设置为 3。那么，全连接层有 128 个隐藏层节点。最后，我们使用 sigmoid 函数进行二元分类。

# 4 实验与评估

## 4.1.实验软件及环境

Pytorch 1.10 用于构建我们的模型框架，Androguard [28] 用于从 APK 中提取函数调用图。 DGL [34] 用于实现 GraphSAGE 模型，Joblib [35] 用于帮助我们并行反编译 APK。环境建立在Windows 10上，具有8GB RAM用于分析和提取，计算使用具有 11GB VRAM 的 Ubuntu 18.04。两个操作系统都安装了 Python 3.7。

## 4.2.数据集

在我们的工作中，我们使用 2017 年 1 月 1 日后从 Androzoo [36] 数据集生成的 6530 个良性 APK 作为我们的良性数据集，并将来自 Drebin [37] 和 CICMalDroid 2020 [38] 的 6368 个恶意软件 APK 作为我们的恶意软件数据集，分别为 3500 和 2868。不过，其中一些APK已被破坏，我们清理了一些无法反编译或无法获取代码资源的APK。数据集分为80%训练集和20%验证集。

同时，我们提前对这些APK进行反编译，利用Python的pickle方法形成序列化文件，这样可以大大减少训练时分析APK文件的时间。

## 4.3.评价指标

我们使用标准指标评估我们的模型，例如准确度、精确度、F1 分数、TPR、FPR 和 AUC。这些指标的计算公式为： $Accuracy =\frac{(TP+TN)}{(TP+TN+FP+FN)}$ ，$Precision = \frac {TP} {(TP+FP)}$ ，$F1 分数 = \frac{2*Precision*Recall }{(Precision+Recall)}$ ，$TPR = \frac {TP} {(TP +FN)}$ ，$FPR = \frac {FP} {(FP+TN)}$ ，AUC 是 ROC 曲线下的面积。在上面的等式中，TP表示正确检测到的恶意软件的数量，FP表示被错误分类为恶意的良性APK的数量，TN表示正确检测到的良性APK的数量，FN表示被错误分类为良性的恶意软件APK的数量。

## 4.4.实验过程及结果

在我们的实验过程中，有许多参数影响我们的实验结果。首先是 GCN 模型的层数。由于 Hamilton 等人的推荐，我们开始使用两层 GCN 模型进行实验。 [32]。 S-FCSG中的不同节点特征逐渐收敛到与不断训练的GCN模型类似。这并不意味着 GCN 模型中的层数越多，我们的方法就越好。我们测试了两层、三层和四层的 GCN 模型对实验结果的影响。我们观察到，当 K = 20 时，三层模型的检测精度更高，如图 15 所示。

![](https://img-blog.csdnimg.cn/direct/d538dc098c0d47399ddd709942fe126d.png)

除了模型层数的影响之外，全局池化层中K值的大小也影响了我们的实验结果。 K值的大小代表从APK文件中提取的行为特征的维度。较高的维度可能包含更多关于行为特征的信息，但也可能导致特征重叠，这不利于学习重要的行为特征。然后，我们测试了 K 值分别为 20、40 和 60 的不同 GCN 层对实验结果的影响。如表5所示，实验结果使用GraphSAGE，以不同层数和K值的自循环图作为输入。

![](https://img-blog.csdnimg.cn/direct/3a26d7765fc241f4bb059998e8c4b536.png)

在表5中，我们发现当GCN模型的层数较低时，K值越大，即节点行为特征的维数越大，结果越好。然而，随着模型层数的增加，这种现象不再明显。随着GCN模型层数的增加，K值为20和40时模型检测的准确率比GCN模型层数为2时更高。这可能是因为节点特征尚未完全聚合GCN模型两层中相邻节点的特征，模型无法在低特征维度下正确识别APK类别。然而，当K值为60时，再次使用多层GCN模型聚合节点特征时，特征可能会重叠，所使用的特征失去了原有的重要性，对模型检测造成干扰，使最终结果变差到双层 GCN 模型。通过我们对不同模型层数和 K 值的实验比较，当层数为 3 且 K = 40 时，GCN 模型在我们的方法中具有最佳结果，准确率为 98.28%。我们的训练过程的epoch设置为150，如图16所示，GCN模型层数为3，K为40的实验过程。当epoch达到150时，损失函数曲线和训练精度曲线已经完全收敛。

![](https://img-blog.csdnimg.cn/direct/908bb431b90c4ba4b56acf7b5b5aff3a.png)

在模型参数相同的情况下，我们比较了GraphConv[31]、GraphSAGE[32]和输入为自循环图的GraphSAGE的结果，如图17所示。ROC图显示使用输入为自循环图的GraphSAGE高于其他两个模型，这表明我们通过在S-FCSG中添加自循环可以有效增强重要节点特征，提高原始模型的分类性能。

![](https://img-blog.csdnimg.cn/direct/f70bfb82ea6449b4bbc5afbdfec13070.png)

我们比较了几种现有的恶意软件检测方法。模型算法从过去的机器学习到最新的GCN模型，使用的特征从单一权限到函数调用图中复杂的行为特征。特别是 Vinayaka 等人提出的方法。 [18]使用FCG作为特征，使用GCN模型进行检测。然而，他们使用读出功能来提取FCG中节点的整体特征，这相当于重要节点特征和无意义节点特征的聚合。表 6 和图 18 将我们的方法与现有方法进行了比较。 AUC的值越接近1，分类器的性能越好。通过比较 AUC 区域的大小和其他指标，我们的方法在 Android 恶意软件检测中具有更好的结果和更高的性能。

![](https://img-blog.csdnimg.cn/direct/2a222156462240e08e1819b7222fe46d.png)

# 5 结论

在本文中，我们提出了一种 Android 恶意软件检测方法，以增强函数调用图（FCG）中节点特征的差异。通过对3.1.3节中提出的函数权重特征的验证，我们知道API的高权限保护级别通常在恶意APK中比在良性APK中更常见。基于FCG，我们获得图中的关键节点并提取它们及其邻居来构建敏感函数调用子图（S-FCSG）。首先，S-FCSG能够捕获重要节点，同时有效减少FCG中的节点数量，最大限度地保留节点特征和结构。然后，S-FCSG去除无意义的节点，防止重要的节点特征在GCN的传播过程中变得无意义，减少低通滤波性对模型学习的重要信息的干扰和实验效果的影响。基于GraphSAGE对节点特征的聚合，我们考虑将我们的节点特征参与到聚合操作中，增加重要节点特征的权重以及不同节点特征之间的差异。通过全局池化层提取重要的节点特征作为S-FCSG的节点行为特征，使得具有重要特征的信息可以方便我们的模型的识别和检测。实验表明，我们的方法比以前基于机器学习的方法和当前基于 FCG 的方法更能识别和检测 Android 恶意软件。

本文主要关注图的节点特征以及GCN模型的特点，但是图结构语义丰富，需要研究的切入点很多，比如图的节点、边、属性、类型等。未来我们首先研究子图提取方法。在我们的方法中，所有数据集都使用相同的子图提取方法。虽然这种方法是有效的，但我们希望采用组合 GraphSAGE [32] 模型的更好的动态子图提取方法。其次，对图中节点的重要评估也有利于研究内容。我们的方法使用特征权重来评估节点的重要程度，以及Huang等人提出的动态评估节点重要性的方法。 [42]是一种非常新颖的方法，值得我们研究。最后，让图的特征信息更加丰富，将更容易识别模型，因此异构图的构建也将是我们下一步的研究步骤。总之，基于图结构和图卷积网络的恶意软件检测有很大的未来研究空间。

# 参考文献

。。。。



---
---
---



阅读目标：研究问题、解决方法、结果、贡献

# 笔记的笔记

# 研究背景

## 静态特征

通过分析源代码或从有关应用程序的其他信息获得的特征称为静态特征[3]。静态分析可以在安装前检测恶意软件，并且可以在模型环境中检测到，从而降低实验成本。

### 传统静态特征

通过反编译APK文件，提取assets、AndroidManifest.xml、classes.dex等文件目录，研究人员可以从AndroidManifest.xml中获取权限、意图等配置，从classes.dex中获取操作码。他们通常将权限、意图和操作码等数据视为 APK 的特征，并将其输入神经网络进行识别和分类。

### 函数调用图 Function Call Graph

函数调用图（FCG）属于一种静态特征。它可以捕获函数的语义信息，而基于权限的静态分析方法则无法做到这一点。

## 动态特性

当Android应用程序在真实设备或模拟器上运行时，获得的运行时行为特征称为动态特征，用于监视网络流量、电池使用情况、CPU利用率、请求和调用等[3]。

# 方法

如图 1 所示是此方法的总体框架。首先对已知类别的APK样本进行图结构数据预处理，生成模型所需的函数调用图及其对应的节点特征矩阵。然后，函数调用图和节点特征矩阵被输入到 GCN 和一维 CNN 模型中。随着模型的前向和后向传播，更新模型的参数并对APK样本进行分类。

![](/img/user/czc知识库/杂七杂八/9-附件/附件/一种基于 GCN 增强函数调用图中节点特征差异的 Android 恶意软件检测方法 An Android Malware Detection Approach to Enhance Node Feature Differences in a Function Call Graph Based on GCNs_image-2.png)

## 特征提取（三种）

从 FCG 和反编译的 APK 文件中提取三种类型的特征。其中两个特征是Dalvik操作码和函数权重，它们是从DEX文件中的每个函数获得的，剩下的一个是基于图结构级别的节点重要性。最后，我们将三类特征连接起来作为FCG的节点特征。

### Dalvik 操作码

Dalvik是Google专门为Android操作系统设计的虚拟机，操作码存在于DEX文件的代码中。从类中的每个方法中提取 Dalvik 操作码，并将其多样性分类为第一个特征。

内部类和外部类：
- 内部类：从反编译APK的DEX文件中获取的，可以获取每个内部类的代码源
- 外部类：源自第三方库，无法获取代码

通过分析DEX文件的内部类的每个函数中的每条指令来获取Dalvik操作码。为了更好地分析每个函数中的这些指令，将它们分为13类
如表2所示。根据Dalvik指令操作码获取对应的关键字和 $i$ 值，存储为`dalvik_opcodes[i] = 1`。外部类的函数表示为 `dalvik_opcodes[0] = 1`。

对于 DEX 文件类中的每个方法，我们将每个方法的 Dalvik 操作码特征表示为 `dalvik_opcodes[i] = 1 (i ∈ [0, 13])`。

![](/img/user/czc知识库/杂七杂八/9-附件/附件/一种基于 GCN 增强函数调用图中节点特征差异的 Android 恶意软件检测方法 An Android Malware Detection Approach to Enhance Node Feature Differences in a Function Call Graph Based on GCNs_image-3.png)

### 节点重要性 Node Importance

FCG 是从反编译的 APK 文件中提取的有向图。在有向图中，每个节点的入度和出度是不同的，而度值可以直接反映该节点的重要性。可以根据节点的入度和出度来分析当前节点的行为特征。通常，对外部类函数节点使用入度，对应用程序初始化函数节点仅使用出度。

在图论和网络分析中，中心性是判断网络中节点影响力的指标。

$$
度中心性=\frac{N_{入度}+N_{出度}}{n-1} \ \ \ \ \ \ \ \ \ \ (1)
$$

虽然度中心性反映了节点的影响力，包括节点的入度和出度，但我们不能用这个度量来判断该节点是否频繁指向其他节点。我们需要节点的入度和出度值来分析该节点在网络中是否扮演发起者、执行者或中间节点的角色。因此，我们将节点的入度和出度与度中心性结合起来作为FCG中每个节点的特征，表示为

$$
节点重要性 = [入度,出度,度中心性]
$$

### 函数权重 Function Weight


计算权重前先*建立两个映射*：**为了创建API和保护级别之间的映射**，需要首先在API和所需权限之间以及权限和保护级别之间进行映射。
- **权限和保护级别之间的映射，从AOSP的AndroidManifest.xml中获取**，
- **API和权限之间的映射**，从Android开源项目（AOSP）中提取API对应的权限，形成API权限映射
	- **使用Java注解@requiresPermission将API与权限关联起来；**
	- **使用@link android.Manifest.permission#来描述API所需的权限。**

通过上面**两个映射**构建API和保护级别之间的映射

根据调用不同API的次数，可以计算出每个函数的API调用权重。

如果API权限有多个保护级别，则仅取保护级别的最大权重值进行计算。对于内部类中的每个函数，我们将每个函数的 API 调用权重表示为等式（2）。相反，对于外部类中的函数，我们将每个方法的API调用权重表示为自身保护级别的权重值，如等式​​（3）所定义。

$$
API\_Call\_Weight_{internal\_method}=\sum\limits^n weight_{protection\ level} \ \ \ \ \ \ \ \ (2)
$$

$$
API\_Call\_Weight_{external\_method}= \max(weight_{API})\ \ \ \ \ \ \ \ \ \ (3)
$$

如果某个函数的API调用权重值较高，则意味着该函数中的API调用次数较多。然而，其他保护级别的 API 调用比危险保护级别的 API 调用要多，这只能意味着该函数中存在更多行为。因此，我们提出了危险防护级别的API调用次数与式（4）定义的API调用总数之间的比率。该比率表示对被识别为危险的 API 的调用的百分比。

$$
ratio_{each\_method}=\frac{dangerous\_api\_call\_counts}{api\_call\_counts} \ \ \ \ \ \ \ \ \ \ \ (4)
$$

我们选择API调用权重、比率及其乘积作为FCG中每个节点的函数权重特征，表示为

$$
method\ weight_{each\_method}=[api\_call\_weight, ratio, api\_call\_weight ∗ ratio]
$$

## 神经网络模型

#### 图卷积网络
与GrapConv的算法相比，GraphSAGE是一种**归纳图嵌入**，**可以嵌入从未出现过的节点**，但GraphConv不能。因此，本文采用 GrapSAGE 作为 GCN 模型
#### 全局池化层
S-FCSG具有**高维邻接矩阵**和**节点特征矩阵**。使用全局池化层来提取**关键特征**并**降低节点特征矩阵的维数**。排序池模型用[33]作为全局池化层。首先沿着GCN模型输出的特征维度对节点特征进行升序排序，并选择排序后的前K个节点的特征权重。经过全局池化层之后，不同维度的节点特征矩阵都可以归一化为同一维度，再将提取的K个节点特征向量组合成K维节点特征矩阵。
#### 一维卷积神经网络和全连接层
一维卷积神经网络和全连接层由三个一维卷积层、一个合并层、一个最大池层和一个全连接层组成。
最后使用 sigmoid 函数进行二元分类。


