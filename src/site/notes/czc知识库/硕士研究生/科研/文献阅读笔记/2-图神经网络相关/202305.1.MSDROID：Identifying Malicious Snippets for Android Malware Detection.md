---
{"dg-publish":true,"permalink":"/czc知识库/硕士研究生/科研/文献阅读笔记/2-图神经网络相关/202305.1.MSDROID：Identifying Malicious Snippets for Android Malware Detection/","dgPassFrontmatter":true,"created":"2024-06-18T17:45:27.022+08:00","updated":"2024-12-08T12:30:21.223+08:00"}
---


相关链接
[zotero的select](zotero://select/library/items/JCYYNSLL)
[zotero的open-pdf](zotero://open-pdf/library/items/5G2LCG6R)
[pdf文件MsDroid_2023_He et al](MsDroid_2023_He%20et%20al.pdf)

关联：
[202301.SriDroid：图卷积网络的抗混淆安卓恶意软件检测，吴月明](202301.SriDroid：图卷积网络的抗混淆安卓恶意软件检测，吴月明.md)，引用这msdroid篇文章，在此基础上改进
[202404.FAGnet：使用图神经网络进行基于家庭感知的 Android 恶意软件分析 Family-aware-based android malware analysis using graph neural network](202404.FAGnet：使用图神经网络进行基于家庭感知的%20Android%20恶意软件分析%20Family-aware-based%20android%20malware%20analysis%20using%20graph%20neural%20network.md)，被曾开发的论文引用
MAMADROID，DEEPMALDET 这篇文章的参考文献，这篇文章的baseline

---
**曾开发说这个文章的代码参考意义不大，因为把所有流程都整合到一起了**

代码实操记录笔记：[MSDROID 实操笔记](MSDROID%20实操笔记.md)

---

之前在网上找到的
期刊：IEEE Transactions on Dependable and Secure Computing （TDSC）（CCF-A）


> 通过androguard静态分析获取应用的函数调用图
> 针对敏感api分析相关代码片段，构建行为子图集（能对应用程序的敏感行为建模）
> msdroid会训练一个神经网络来训练分类器


安卓恶意软件检测，图神经网络（GNN），可解释性机器学习，静态代码分析
**有代码**和图数据集

SriDroid中对它的介绍：MsDroid 首先通过静态分析获取应用的函数调用图, 然后针对敏感 API 分析相关的代 码片段, 并以此构建行为子图集. 由于恶意代码一般是在围绕敏感 API 的几个片段中得以实现, 因此, 子图集 的片段表示方法能够对应用程序的敏感行为进行建模. 获得子图集之后, MsDroid 会训练一个图神经网络来训 练分类器, 并以此识别恶意行为

---
# 笔记的笔记
据我们所知，我们是第一个将GNN应用于静态代码分析的Android恶意软件

提取特征：调用图、操作码、权限
- Opcode对测试性能的提升最大，但对新样本来说是最脆弱的特征。
- 权限是对超时应用演化最稳健的特征。
- 调用图结构使得模型具有更强的异常检测能力。


### 文章内关于数据集的信息
我们开源了我们的代码和图数据集
我们利用三个流行的学术数据集来构建我们的APK数据集，即Drebin[2]，AMD[30]和Androzoo[43]。
我们的**图数据集由APK数据集**的调用图生成的2 602 408个行为子图组成
### 参考技术
我们使用MaMaDroid的源代码来生成特征


---
# ↓下面是译文↓
# 摘要
> 在文献中，机器学习已经显示出提高Android恶意软件检测准确性的希望。然而，这是具有挑战性的: (1) 保持对现实世界场景的鲁棒性和 (2) 提供可解释的解释供专家分析。在本文中，我们提出了MsDRoID，这是一个Android恶意软件检测系统，通过识别带有可解释解释的恶意代码片段来做出决策。我们模仿了安全分析师的一种常见做法，即**在查看每种方法之前过滤api，以关注敏感api周围的本地代码片段**，而不是整个程序。**每个片段用编码代码属性和领域知识的图表示，然后用图神经网络(GNN)进行分类**。局部视角帮助GNN分类器专注于与恶意行为高度相关的代码，图中包含的信息有助于更好地理解行为。因此，MsDRoD在本质上更具鲁棒性和可解释性。为了识别恶意片段，**我们提出**了一种**只需要应用标记**的半监督学习方法。关键的见解是，恶意代码片段只存在于恶意软件中，并且在恶意软件中至少出现一次。为了使恶意代码片段不那么不透明，**我们设计**了一种解释机制来显示控制流的重要性，并从已知恶意软件中检索类似实现的代码片段。在包括零日攻击、进化和混淆在内的3个真实场景中，对超过81K个应用程序的数据集进行了与5种基线方法的全面比较。实验结果表明，MsDRoID在所有情况下都比最先进的系统更健壮，f1得分优势为5.37%至49.52%。此外，我们还证明了所提供的解释是有效的，并说明了这些解释如何促进恶意软件分析。

# 1 介绍
   ANDROID恶意软件层出不穷，在2020年报告了超过8300万新的恶意软件感染[ 1 ]。现有的工作探索了机器学习( ML )在Android恶意软件检测中的应用，以减轻人工分析的负担，似乎取得了巨大的成功[ 2 ]，[ 3 ]，[ 4 ]，[ 5 ]，[ 6 ]，[ 7 ]，[ 8 ]。然而，该问题至今仍未得到妥善解决。指出在现有的工作中，由实验偏差引起的过度乐观的结果是普遍存在的[ 9 ]。在现实世界中，Android应用程序随着时间的推移以不同的实现和功能快速演化[ 10 ]。软件开发人员和恶意软件作者对混淆技术的使用也在快速增长[ 11 ]，[ 12 ]。此外，现有的恶意软件分类器大多被设计为黑盒，无法为进一步的分析提供有意义的信息。

   聚焦于使用从静态代码分析中提取的特征的基于ML的Android恶意软件检测方法，我们观察到技术的进步一般在两条路径上进行。首先，学习过程从模式驱动转向数据驱动，变得更加独立于人工设计的属性[ 5 ]，[ 7 ]，[ 13 ]。特别地，基于序列的方法从字节码中提取API或操作码的原始序列，避免了复杂的特征工程[ 4 ]，[ 14 ]。这些方法大多得益于深度学习技术(例如, CNN , RNN等)在NLP任务中的成功，而没有特别考虑程序中必不可少的控制流信息。其次，许多工作结合多种特征来提高下游分类器的恢复能力[ 15 ]。例如，Arp等人[ 2 ]在特征空间中串联了八组特征，Kim等人[ 6 ]提出使用多模态学习来联合训练不同的特征。这些设计分离了不同的特征集，而没有考虑预处理过程中的隐藏关系。总之，现有的特征表示方法无法捕获足够的关系，从而降低了下游分类器在行为建模中的性能。

   现有的一些工作用单独特征的权重来解释ML决策，例如，特定的API或权限[ 16 ]，[ 17 ]。例如，DREBIN [ 2 ]将SVM的权重与其基于模式的特征的重要性联系起来。一些现有的基于神经网络( NN )的检测方法提供了有意义的解释[ 18 ]。公平地说，可解释性的困难是基于NN技术的一个继承的挑战。现有的解释技术都没有探索控制流背后的逻辑，无法识别恶意软件中的恶意片段。

   考虑到这些问题，我们旨在通过填充恶意软件表示中的缺失关系来增强现有方法的鲁棒性。此外，我们的目标是使检测结果更具有可解释性，以便进行进一步的安全性分析。为了应对这些挑战，我们从构建基于图结构数据的APK表示开始。有两个动机：1.图数据在表达关系方面优于常规的欧式结构化数据；2.分析器可以用图进行更精细的关系探索，以进行更具有可解释性的推理过程[ 19 ]，[ 20 ]。为了自动地将图结构编码为低维嵌入而不妥协[ 21 ]，[ 22 ]，[ 23 ]，[ 24 ]，[ 25 ]，我们利用GNN技术进行归纳图级分类。

   我们提出了一种称为行为子图集( BSS )的代码片段表示方法来建模Android应用的敏感行为，其关键见解是恶意代码是在敏感API附近的几个代码片段中实现的。为了提取特征，我们排除了字符串和资源文件等行为属性[ 26 ]，而选择了三个健壮的属性，即**调用图、操作码和权限**。前两者的使用在现有的数据驱动方法[ 27 ]、[ 28 ]、[ 29 ]中都很直观和常见。涉及后者的动机是：1 )权限决定了应用程序是否可以访问某些敏感数据，因此与恶意行为高度相关；2 )权限是Android基于权限的安全模型定义的，是一种比较稳定的知识。此外

- 调用图对于在图级分类任务上训练一个GNN来说过于庞大，例如流行的学术APK数据集AMD [ 30 ]的调用图平均有7K个节点和19K条边；
- 调用图对于恶意软件检测任务来说是冗余的，这阻碍了行为捕获。

   因此，我们将app分类问题转化为子图分类任务。基于恶意软件至少有一个恶意行为而良性应用没有恶意行为的观察，我们提出应用子图损失来处理半监督训练过程。

   MSDROID在一个跨越6年的81790个Android应用程序的数据集上进行了性能评估，取得了97.82 %的测试准确率。我们还进行了广泛的评估，将MSDROID与五个基线模型在有效性和可转移性方面进行了比较。特别是对于可迁移性，我们考虑了恶意软件检测领域的三个关键问题，包括零日威胁、应用程序演化和代码混淆。评估结果表明，MSDROID比现有方法(即MAMADROID  , DEEPMALDET  )在测试集上的准确率高达9.15 % F1值，在零日恶意软件上的准确率为38.47 %，在演化应用上的AUT ( f1 )为37.81 %，在混淆应用上的F1 - sore为26.12 %。在反射混淆上，MSDROID的F1值分别提高了49.52 %和47.02 %，并通过行为子图统计和利用提出的解释机制的案例研究进一步解释了这一成功。此外，我们对恶意软件家族的第一层解释结果进行了分析，并证实了其与实际行为的一致性。在一个混淆应用程序和一个COVID - 19主题应用程序上进行的两个案例研究也展示了所提出的解释机制如何帮助真实世界的恶意软件分析。

   研究发现。由于MSDROID联合了三类特征，我们在不同的场景下衡量了它们的有效性，研究结果如下：

- Opcode对测试性能的提升最大，但对新样本来说是最脆弱的特征。
- 权限是对超时应用演化最稳健的特征。
- 调用图结构使得模型具有更强的异常检测能力。

## **贡献**

**据我们所知，我们是第一个将GNN应用于静态代码分析的Android恶意软件**(新闻片断)检测。我们工作的**主要贡献**总结如下：

- 我们设计了一种新颖的基于代码片段的 Android 恶意软件检测器，名为 MSDROID，它使用 GNN 识别恶意软件中的恶意代码片段。我们用图表示每个片段，使用强大的行为属性（包括调用图、操作码和权限）来保留调用和跨模式关系。我们提出了一个定制的损失函数来训练片段分类器，不需要专门的标记工作。
- 我们在超过81K个应用程序的数据集上评估了MSDROID，并在4个设置中与5个基线技术进行了全面的比较。实验表明，MSDROID达到了97.82 %的测试准确率，并且在零日威胁、应用演化和代码混淆方面的鲁棒性明显优于现有方法。尤其是在反射混淆上，F1值最高高出49.52 %。此外，我们还得到了三个特征有效性的发现。
- 我们提出了一个三级解释机制以方便恶意软件分析。它识别可疑的API使用，通过调用热图可视化恶意代码，告诉可疑的控制流，并给出已知恶意软件的类似行为片段。通过一个家庭分析和两个案例研究，该机制被证明是有用的。

<font color="#ff0000">我们开源了我们的代码和图数据集</font>

# 2 概述（overview）

## 2.1 问题定义

给定一个安卓app，一个恶意软件检测系统需要区分它是否是恶意的。由于静态调用图旨在通过表示每一个可能的运行来近似真实程序的行为，因此它可以作为NN算法探索的信息代理。这里将调用图形式化的定义为$G=(V,\varepsilon)$，其中每个元素$v\in V$代表一个API，每条边$e=(v_1 , v_2)\in \varepsilon$表示从$v_1$到$v_2$的调用

然而，恶意行为通常包含在恶意代码的片段中，比例估计为0.18 %，远远超过非恶意代码[ 31 ]，[ 32 ]。基于恶意行为通常在几个语义丰富的API中实现的观察，我们提出了行为子图集( Behavior Subgraph Set，BSS )来表示每个程序的一组可能的恶意代码片段。然后，我们将恶意软件检测问题分解为子图分类问题。BSS和检测问题定义如下：

**行为子图集( BSS )**。行为子图集合G是具有节点特征的图集合，如式( 1 )所示：

$$
\{ g=(G[S],X) \  | \  G[S] \in sub(G),X=nod(S|G) \} \ \ \ \ (1)
$$

其中$G[S]$是一个顶点集为$S\subset V$的调用图G的导出子图，$sub(\cdot)$是生成子图集$\{G[S_i]\ |\ i\leqslant n,n\in \mathbb{N}_+\}$的方法；$nod(\cdot)$定义了每个节点集$S_i$生成API特征$X_i$的方式。

**分解检测问题**。只要存在恶意行为，Android应用就是恶意的。因此，给定一个分类器$C:g\rightarrow\{0,1\}$把每个恶意行为映射到一个正值，一个具有行为子图集G的应用的检测输出应该是：

$$
sign\left( \sum_{g\in G} C(g) \right) \ \ \ \ (2)
$$

如果输出结果为正，则检测出恶意软件。否则，输入的app被视为良性的。

根据定义，两个主要的检测任务应该是：1 )设计$sub(\cdot)$和$nod(\cdot)$来为Android应用程序生成G，以捕获足够的行为语义；2 )构建C在没有明确标注的情况下对行为子图进行自动学习，并推广到恶意软件识别中。

## 2.2 系统结构

![](/img/user/czc知识库/杂七杂八/9-附件/附件/MSDROID：Identifying Malicious Snippets for Android Malware Detection_image.png)
如图1所示，MsDroid经历四个阶段：1、预处理，2、BSS生成，3、GNN检测，4、后处理。中间的两个阶段是对两个检测任务的对应解决方案。为了帮助安全分析，MSDROID还在最后阶段努力解释恶意软件片段。

首先，MSDROID对Android应用进行拆解，通过静态分析提取调用图。应用程序还被发送到API权限检查和第三方库检测。其次，子图集的生成由与权限相关的API引导。将每个子图的节点分为四种类型，并据此提取节点特征。然后，MSDROID利用GNN技术对图结构数据(即行为子图)进行自动学习，以识别恶意行为。特别是在训练时，由于没有显式的子图标签可用，提出了一个app子图损失函数。对于一个恶意应用，基于子图预测、GNN模型解释和图嵌入相似性三个层次做出可解释的检测结果。

# 3 方法
在这一部分，我们讨论了MSDROID四个阶段的技术细节。
## 3.1 预处理
对于一个输入应用，MsDRolD在Androguard的帮助下对其进行反汇编并提取调用图G[ 33 ]。API语义有两种收集方式。（1）为了区分与权限相关（即“敏感”）的API $V_{per}\subset V$ ，MsDRolD利用了来自PSCout[34]和Axplorer[35]的两种常用的api-权限映射。但是，Android应用程序可以对内容提供程序执行CRUD（创建、检索、更新和删除）操作这些操作也可以访问敏感权限。例如，查询“content://mms”涉及权限“READ_SMS（读取短信）”。由于CRUD(create创建、retrieve检索、update更新、delete删除)操作是由来自ContentResolver接口的方法处理的，MsDRIOD分析这些方法并将api权限映射补充为$M_{per}$（2）为了识别属于独立功能模块的api，MsDRolD使用LibRadar[36]来检测应用程序内的第三方库（tpl）。

## 3.2 行为子图集生成（BSS Generation）
### 3.2.1 子图集的生成（Subgraph Set Generation）
MSDROID将代码片段中的每个权限访问视为感兴趣的行为，基于$G$上与权限相关的API的k-hop邻域实现$sub(\cdot)$。特别地，对于每个$v_i\in V_{per}$，一个行为子图是由$S_i(|S_i|>1)$引起的，这意味着它有$S_i$作为它的顶点集，并且保留了$G$中所有在$S_i$中具有两个端点的边。因此，一个子图的生成过程等价于选择节点集$S_i$ 。选择通过以下步骤完成：
- **初始化**（Initialization）。节点集合用$V_i$的k-hop邻域$N_k(v_i)$初始化。邻居节点被选择的原因是可能直接或间接调用敏感API或被这些调用者调用，最有可能包含恶意片段。
- **划分**（Partition）。利用前面收集的API语义，将$N_k(v_i)$划分为四个子集。对于外部API (不拆解字节码)，根据其是否存在于$M_{per}$中，属于$S_{per}$还是$S_{non}$。对于内部API，那些属于TPL的API被归类到$S_{tpl}$中，否则被视为$S_{usr}$中的用户自定义API。
- **还原**（Reduction）。从子集中删除三种类型的节点：( R1 ) $S_{tpl}$、$S_{per}$和$S_{non}$中不被$S_{usr}$中任何节点直接调用的节点，( R2 ) $S_{usr}$中实际不能到达$v_i$的节点，( R3 )与$v_i$隔离的剩余节点。
如果得到的子集$S_{usr}$不是空集，则将$v_{i}$添加到$S_{per}$中，并由这四个子集的并生成一个诱导子图。

我们用一个图2所示的玩具例子来解释Reduce背后的直觉。首先，在恶意软件检测中，集成到应用程序中的TPL通常非常大，以至于构成噪声[ 37 ]。为了理解恶意软件的行为，我们可能只想知道TPL的功能而不是实现细节。由于图中调用图的左边部分来自TPLs中的代码，因此我们减少了大量的代码体，只保留由' A '直接调用的' G '和' D '。第二，一些用户自定义的方法被错误地包含为$N_k(v_i)$中感兴趣的当前行为。例如，包含' J '是因为它调用了与' A '相同的不敏感的外部API ' I '。如果"I"执行诸如android.util.Log.d( )这样的基本实用程序，这将是一种常见的情况。最后，单节点' L '和' K '被移除，因为它们先前是由' J '引入的，我们认为它们来自不同的行为片段。

### 3.2.2 API特征生成
MSDROID通过解析$\{S_i\}$中被反汇编的字节码和请求的API权限来实现nod(·)。如算法1所示，节点特征是操作码和权限特征向量的串联(第14行)。生成这两个特征向量的主要功能如下：1 ) GetOpVector (第6行)计算内部API不同操作码的归一化频率，输出外部API的零向量；2 ) GetPerVector (第7行)生成二进制向量，表示是否需要某个API的权限，该向量为$M_{per}$中外部API的非零向量。需要注意的是，第二个功能不能直接作为API名字匹配来实现。为了更好的理解，我们在这里给出了一个例子：如果A类继承于SmsManager类，并且A类不覆盖API sendTextMessage()，因此，尽管精确匹配与SmsManager.sendTextMessage()一样，也不能将A.sendTextMessage()识别为敏感的。为了解决这个问题，MSDROID递归地找出外部节点的基类，并在$M_{per}$中查找所需权限之前替换类名。
由于在子图结构中简化了tpl的使用，MsDROID通过聚合后继节点的权限特征来丰富$S_{tpl}$中节点的行为语义(第8-13行)。GetSenNodes应用Depth-First-Search来获取n的敏感子节点。在搜索过程中，异步调用被额外处理，其中调用约定$M_{asy}$将RunMethod映射到StartMethod被建议使用[28]。内部TPL API的最终权限向量是其敏感子节点的平均值。例如，'D'的$v_{per}$（图2)是对'H'和C'的平均值。

![400](/img/user/czc知识库/杂七杂八/9-附件/附件/MSDROID：Identifying Malicious Snippets for Android Malware Detection_image-4.png)

## 3.3 GNN-Based Detection
### 3.3.1 构建基于GNN的分类器
在图数据上，图神经网络( Graph Neural Networks，GNNs )可以比传统的基于描述符的方法产生更有前途的结果[38],[39]。在图数据上，图神经网络(graphNeuralNetworks,gnn)比传统的基于描述符的方法能产生更有希望的结果[38]，[39]。它们广泛地遵循递归邻居消息传递方案，其中每个节点聚集从邻居处提取特征向量来更新自身的特征向量。经过几次聚合迭代后，每个节点用一个捕获一定信息的特征向量来表示，通过图池化就可以得到整个图的表示。
MsDROID采用消息传递方案，在图级任务上实现SOTA性能[25]，用于行为子图分类。它使用MLP技术更新节点特征如下：

$$
h_v^{(i)}=MLP^{(i)} \left( (1+\epsilon^{(i)})\cdot h_v^{(i-1)}+\sum\limits_{u \in \mathcal{N(v)}} h_u^{(i-1)} \right) \ \ \ \ (3)
$$

其中$h_v^{(i)}$为节点$v$在第$i$次迭代时的特征向量，$\mathcal{N(v)}$为与$v$相邻的节点集合。
为了构建$\mathcal C$，我们首先实现具有两个128个神经元隐藏层的MLP，并使参数$\epsilon$为固定标量为0。其次，API节点表示在3次迭代中更新。接下来，我们在图级读出函数中结合全局最大池化和平均池化，将每个行为子图嵌入为：

$$
h_{G^B}= max(h_v | v \in G^B) || avg(h_v|v \in G^B) \ \ \ \ (4)
$$

直觉上，最大池化学习不同的元素，而平均池化学习分布。由于异常API使用和类似使用的恶意软件API对于恶意软件检测都是有价值的，因此所提出的方法在实验上也比单独使用最大池化或平均池化更好。最后，添加了一个用于消息后传递的两层MLP来输出两类预测。
### 3.3.2训练与测试
与许多二进制分类任务一样，Android恶意软件分类器通常以监督方式进行训练。这种方法很简单，而且由应用程序及其标签组成的大规模数据集很容易获得。然而，为了训练识别恶意行为的C语言，我们不能使用相同的方法，因为恶意代码的大规模标记需要付出巨大的努力，而且还没有引起人们的注意。基于良性应用程序没有任何恶意行为，而恶意软件至少有一种恶意行为的认识，我们使用现有的应用程序标签来执行半监督训练。换句话说，良性应用的所有行为子图都得到标签0，但对于恶意应用来说，每个行为子图的标签都是不确定的。为了解决训练$\mathcal C$中的挑战，我们将损失函数设计如下。
AppSubgraphLoss。每个带有$BSS\  \mathcal G$和标签$y$的应用的预测损失计算为：

$$
-\left( (1-y){\dfrac{1}{| \mathcal G |}} \sum\limits_{g\in \mathcal G}log(1-p_g)+y\ \min\limits_{g \in \mathcal G}log(p_g)  \right) \ \ \ \ (5)
$$

式中$p_g$表示行为子图$g \in \mathcal G$的类1预测概率。第一项旨在确保良性应用中预测行为子图的准确性；第二项旨在使恶意软件中最有可能是恶意的子图具有高概率。请注意，可以用加权和等其他方法代替(5)中的最小池化，但在实践中，简单的最小池化可以导致更少的误报。
在测试期间，对于训练好的$\mathcal C$，我们使用(2)来汇总每个应用程序的行为子图的预测结果。也就是说，如果$\{C(g)\}$中存在输出标签1，则将应用程序分类为恶意软件。
## 3.4 恶意软件解释
MsDROID为恶意软件生成三种解释结果（即可疑API用法调用热图，类似行为片段），主要是为了方便逆向工程。图3展示了解释一个可疑行为的整体工作流程，在4.4节中可以找到真实世界应用程序的更具体的示例。我们介绍了设计的原因和实现如下。
![](/img/user/czc知识库/杂七杂八/9-附件/附件/MSDROID：Identifying Malicious Snippets for Android Malware Detection_image-5.png)
### 3.4.1 可疑API使用情况
MsDROID在API和权限级别上提供了一些现有作品的解释。结果很自然，因为应用程序的检测决策是根据其行为子图的分类结果做出的。每个子图捕获围绕某个敏感权限相关API实现的行为。因此，对于检测到的恶意软件，我们给出其所有被归类为恶意的行为子图，以及相应的具有权限语义的敏感api(例如，行为类别)。
### 3.4.2 调用热度图
![](/img/user/czc知识库/杂七杂八/9-附件/附件/MSDROID：Identifying Malicious Snippets for Android Malware Detection_image-6.png)
由于行为子图在边缘上包含程序范围的控制流信息，我们进一步识别那些对实现恶意行为至关重要的重要控制流，并使用调用热图将其可视化。恶意软件可疑使用的APl isWifiEnabled() 的示例调用热图如图4c所示（参见附录D中的节点映射，可在计算机协会数字图书馆[CSDL | IEEE Computer Society](http://doi.ieeecomputersociety.org/10.1109/TDSC.2022.3168285))
受*圆形布局*（如图4a所示)的启发，我们为具有多个节点类型的图设计了布局算法，其中第j个节点在第i类节点集$S_i$中的位置计算为：

$$
\begin{cases}
x_{i,j}=R_1\cos(\frac{2\pi}{N}i)+R_2\cos(\frac{2\pi}{N}j),
\\ 
y_{i,j}=R_1\sin(\frac{2\pi}{N}i)+R_2\sin(\frac{2\pi}{N}j),
\end{cases}
\ \ \ \ \ \ \ \ (6)
$$

将所有节点按类型定位并上色后，得到图4b。正如我们所看到的，一个行为子图可以有几十条(甚至几百条)边，所以接下来我们介绍它们的重要性是如何学习的。
边权重学习(*Edge Weights Learning*)。我们确定了基于GNN的模型预测边缘权重的重要性。该问题被表述为一个优化任务，该任务最大化GNN预测与可能的边缘依赖关系分布之间的互信息(MI)[40]。这意味着，给定一个行为子图$G^B=(\mathcal V^B,\mathcal E^B)$，如果去除边缘子集$E_s\in E$会强烈降低分类器C做出原始预测y的概率，那么这些边缘的缺失可以是一个很好的反事实解释。专注于恶意类，使用掩码方法的计算高效版本的客观表述如下：

$$
\min - \log P_C(Y= 1|E=A\odot \sigma (M)), \ \ \ \ \ (7)
$$

其中，$A \in \mathbb N^{n \times n}$ 表示行为子图 $G^B$ 的邻接矩阵，$\odot$表示逐元素乘法，$\sigma$是将学习到的边掩码<font color="#595959">(edge mask)</font>$M\in \mathbb R ^{n\times n}$映射到$[0,1]^{n \times n}$的sigmod函数。为了提供更有意义的解释，我们在(7)中添加了三个正则化 <font color="#595959">(regularization)</font> 项：a)元素熵以鼓励离散的边掩码；B)elementwisesum惩罚大尺寸的解释；c)o(M)中映射到端点节点在Sron中的边的元素之和，以阻止解释边以非敏感的Androidapi结束。
矩阵o(M)中的元素是我们在调用热图时用作边权重来确定边颜色的元素。因此，逆向工程师可以围绕重要的API依赖项（即深色边缘）跟踪恶意代码。
### 3.4.3 相似行为片段
代码克隆搜索支持许多关键的安全用途，并且可以减少逆向工程中手工分析的负担[41]，[42]。在恶意软件分析场景中，如果在已知的恶意软件数据库中发现任何类似的实现行为，专家可以根据先验知识定位恶意代码。MsDROID可以通过计算行为子图之间的相似性来实现这一点。我们将图级读出函数后的嵌入作为行为表示。因此，对于$e_1$和$e_2$两个行为表示，它们之间的相似度计算为：

$$
sim(e_1,e_2)=1/d(e_1,e_2), \ \ \ \ \ \ \ \ \ \ \ \ (8)
$$

也就是它们的欧几里得距离的倒数。此外，为了加快搜索过程，我们将那些以相同敏感api为中心的行为子图分组。因此，对于给定的行为子图，相似性计算只需要在一组中进行，这大大减少了两两计算的代价。
# 4 评价
## 4.1 Experimental Setup
我们用Python实现我们的系统，并在GitHub上发布代码。具体来说，我们使用带有“DAD”反编译器选项的Androguard执行APK分析，并在预处理期间使用LibRadar检测第三方库。图的生成和学习过程是基于PytorchGeometric框架实现的。解释机制中的图形可视化是借助Networkx包完成的。现在我们介绍我们在评估中使用的数据集和基线技术。

### 4.1.1 数据集
我们利用三个流行的学术数据集来构建我们的APK数据集，即Drebin[2]，AMD[30]和Androzoo[43]。由于前两个是经过充分研究的带有家族标签的恶意软件数据集，因此我们保留了其中的所有应用程序。然后在Androzoo的帮助下，我们收集了VirusTotal中所有AVs (Antivirus software)（防病毒软件）报告为良性的应用程序我们的良性集合如下：
1)**老的**：出现时间戳与Drebin日期范围相同的下载应用，有11,580个应用；
2)**New**：将与Drebin不重叠的AMD日期范围划分为4个11个月的时间段，每个时间段收集1万个app，形成一组4万个良性app。最后，我们的APK数据集包含81,790个Android应用程序，跨越6年，其中包括30,210个恶意和51,580个良性。此外，我们对Drebin和Old进行了混淆处理，得到了混淆后的数据集用于可转移性评估，并使用COVID-19主题应用程序[44]进行了案例研究分析。
![](/img/user/czc知识库/杂七杂八/9-附件/附件/MSDROID：Identifying Malicious Snippets for Android Malware Detection_image-2.png)
<font color="#ff0000">我们的图数据集由APK数据集的调用图生成的2 602 408个行为子图组成</font>。由于反编译器的失败，一些调用图不能成功地从APK中提取出来。但是由于每个子数据集的反编译失败率相似，都在3.5 %左右，恶意软件在满足空间一致性的前提下，比值不会受到太大的影响。图数据集的详细信息见表1。从调用图统计中，我们可以看到较新的app往往比较大，它们的调用图平均有上千个节点和上万条边。不同的是，对于基于两跳的行为子图，虽然应用程序的子图数量随着时间的推移而增加，但图的大小却在减小。此外，与恶意软件相比，良性应用程序在行为子图中具有更少的节点和边。这个结果也暗示了我们的子图缩减步骤对于效率和有效性都是必要的。
### 4.1.2 Baseline Techniques（参考技术）MAMADROID、DEEPMALDET
~~Baseline就是参照物，可以是最基础的模型，业界的普遍做法，或者你要去pk的对手玩法。选取什么作为Baseline那就看你的目的咯~~
首先，我们对API节点特征使用掩码方法来研究我们的方法的特征有效性。具体来说，我们将保留操作码或权限特征的模型分别称为MsDROID-OPC和MsDROID-PER。将所有节点特征设置为相同数值的模型称为MsDROID-NON。其次，我们将我们的方法与两种最先进的恶意软件分类器进行比较，这两种分类器使用与我们相同的程序属性（即DEX文件）来生成特征：a)MAMADROID[3]将每个API的调用图与其族或包名称抽象为一阶马尔可夫链，然后使用成对转移概率作为特征向量；<font color="#ff0000">我们使用它们的源代码来生成特征</font>，并选择包模式，因为它的性能要比族模式好得多；我们使用其论文中声称的配置实现随机森林分类。b)DEEPMALDET[4]从每种方法中提取一个操作码序列，并将所有类的操作码序列连接起来，给出一个代表整个Android应用程序的操作码序列;然后使用卷积神经网络（CNN)进行分类；<font color="#ff0000">我们使用GitHub上发布的源代码重新运行他们的系统</font>。
在下面的章节（章节4.2,4.3,4.4)中，我们通过回答三个主要的研究问题来评估MsDROID的性能：
- RQ1:MsDROID在大规模数据集上的性能如何？
- RQ2:MsDROID在有效性和可转移性方面是否优于基线技术？
- RQ3:MsDROID的解释机制能否为恶意软件提供有用的见解？
## 4.2 检测性能
在这一部分中，我们通过评估整个数据集上的检测和运行时性能来回答RQ1。我们从每个子数据集( Drebin , AMD , Old , New)中随机选择80 %的app组成训练集，并在其余的app上测试检测性能。我们在所有的实验中都遵守这一训练测试分裂规则。
**参数选择**。我们系统中的超参数是模型的隐层嵌入维数和子图切片期间的跳数。为了确定这两个超参数，我们在Drebin和Old上做了实验。首先，我们将嵌入维数从16、32、64、128改为256，并固定跳数为2。它们在800epoch内的最佳测试结果如表2所示，我们还计算了模型参数数，并计算了前向传播的平均乘法累积操作（multiple-accumulateoperations,mac)。值得注意的是，在维数从128增加到256之前，更大的嵌入可以带来更好的性能。然后通过将嵌入维数固定在128，我们生成3跳和4跳的行为子图，因为我们在分类器中使用了三个图卷积层。如表所示，3跳子图的性能精度下降0.3%，而在mac上的计算成本比2跳子图高25M。对于4跳条件，最大的子图达到38618个节点和229802条边的大小，并且由于内存限制，学习过程中断。所以在我们的系统中，我们推荐跳数为2，嵌入维数为128，其余的实验都配置了这个设置。由于可以在移动设备上使用较小的有效性损失的情况下进行较小的嵌入，因此我们在附录a中讨论了性能和计算之间的权衡，可在在线补充材料中获得。
**在大规模数据集上的性能**。大规模数据集上的性能。用四个指标来评价模型的性能。1)精准度：识别出的恶意软件中，实际属于恶意的比例；2)召回率：真实恶意软件被识别为恶意的比例；3）准确率：所有应用被正确分类的比例；4)F1-score:Precision和Recall的调和平均值，计算为2x（PrecisionxRecall)/(Precision+Recall)。就像在表3，在81,790个应用程序的数据集上，MsDROID实现检测精度98.13%。此外，从图5中，我们观察到随着训练数据量的增加，准确率明显提高，我们可以推断，如果向我们的模型提供更多的数据，可以获得更好的性能。MsDROID的运行时性能与数据集中子图的数量和大小密切相关。我们使用NVIDIA Tesla V100 GPU，并在训练和测试阶段报告性能如下。训练一批大小为64的数据平均大约需要16秒，即当使用整个数据集时，一个epoch需要**4.5小时**。培训过程相当长，但在离线环境中是可以接受的。然而，在线测试工作得很好，因为1) 测试避免了计算梯度和更新权重的反向传播过程；2) 批归一化是前向传播中最耗时的操作之一，在测试中花费的时间要少得多。以一个大致等于平均大小（35个节点，122条边）的恶意软件子图为例，预测时间估计为14.67毫秒。

## 4.3 基线比较

### 4.3.1 有效性

### 4.3.2 可转移性

## 4.4 解释分析

### 4.4.1 族系分析

### 4.4.3 案例分析2.最新应用

# 5 讨论

# 6 相关工作

## 6.1 基于学习的Android恶意软件检测

## 6.2 用于代码分析的图学习

# 7 结论

